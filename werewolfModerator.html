<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Werewolf Moderator (Single File)</title>
  <style>
    :root { --bg:#0b1020; --card:#121a33; --muted:#9aa6c3; --txt:#e7ecff; --bad:#ff5b6e; --good:#62ffa7; --warn:#ffd166; --header-h:48px; }
    *{box-sizing:border-box;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
    html{background:#0b1020}
    body{margin:0;min-height:100vh;background:linear-gradient(180deg,#070a14,#0b1020);color:var(--txt);overscroll-behavior-y:none;padding-top:var(--header-h)}
    header{padding:8px 12px;border-bottom:1px solid rgba(255,255,255,.08);position:fixed;top:0;left:0;right:0;height:var(--header-h);background:rgba(11,16,32,.85);backdrop-filter:blur(8px);z-index:10;display:flex;align-items:center;justify-content:space-between;gap:8px}
    h1{margin:0;font-size:18px;line-height:1}
    .wrap{max-width:1100px;margin:0 auto;padding:16px}
    .row{display:flex;gap:12px;flex-wrap:wrap;flex-direction:column}
    .row.inline{flex-direction:row;flex-wrap:nowrap}
    .col{flex:1;min-width:0}
    .card{background:rgba(18,26,51,.9);border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:14px}
    .muted{color:var(--muted)}
    button{cursor:pointer;border:1px solid rgba(255,255,255,.12);background:#1a2550;color:var(--txt);padding:10px 12px;border-radius:12px;font-size:14px}
    .btnCompact{padding:6px 8px;font-size:12px}
    .btnMatch{padding:10px 12px;font-size:14px;width:100%}
    button:hover{filter:brightness(1.08)}
    button.secondary{background:transparent}
    button.danger{background:#4a1520;border-color:rgba(255,255,255,.08)}
    button.good{background:#0f3a2a;border-color:rgba(255,255,255,.08)}
    button.warn{background:rgba(255,209,102,.18);border-color:rgba(255,209,102,.35);color:var(--warn)}
    button:disabled{opacity:.5;cursor:not-allowed}
    .disabledLike{opacity:.5;cursor:not-allowed}
    input, select, textarea{width:100%;padding:10px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.12);background:#0f1631;color:var(--txt)}
    textarea{min-height:110px;resize:vertical}
    .screen{display:none}
    .screen.active{display:block}
    .topbar{display:flex;flex-direction:column;align-items:flex-start;gap:8px;margin-bottom:12px}
    .screenTitle{width:100%;text-align:center;font-size:20px;letter-spacing:1px;text-transform:uppercase}
    .rolesTotalText{text-align:center;font-size:16px;font-weight:600;width:100%}
    .dayTimerText{text-align:center;font-size:24px;font-weight:600;width:100%}
    .lynchTimerText{text-align:center;font-size:22px;font-weight:600;width:100%}
    .badge{display:inline-block;padding:4px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.05);font-size:12px}
    .pill{display:inline-flex;gap:6px;align-items:center;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.05);font-size:12px}
    .totalPill{font-size:14px}
    .grid{display:grid;grid-template-columns:1fr;gap:8px}
    .playerBtn{
      display:flex;align-items:center;justify-content:space-between;gap:8px;
      padding:10px 12px;border-radius:14px;border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.05);text-align:left
    }
    .playerBtn.evil .name, .playerBtn.evil .mini{color:var(--bad)}
    .playerBtn.other .name, .playerBtn.other .mini{color:var(--warn)}
    .playerBtn .name{flex:1;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
    .playerBtn .mini{white-space:nowrap}
    .roleHighlight{box-shadow:0 0 0 3px #fff}
    .nightNav{display:flex;gap:8px;width:100%}
    .nightNav button{flex:1}
    .selectionSummary{margin-bottom:8px}
    .modPromptRow{display:flex;gap:8px;align-items:stretch;margin-bottom:10px;width:100%}
    .modPromptIcon{
      width:36px;min-width:36px;flex:0 0 36px;display:flex;align-items:center;justify-content:center;
      border:1px solid rgba(255,255,255,.12);border-radius:12px;background:rgba(255,255,255,.05);
      align-self:stretch
    }
    .modPromptInput{
      min-height:70px;line-height:1.4;font-size:14px;color:var(--txt);
      border:1px solid rgba(255,255,255,.12);background:#0f1631;border-radius:12px;
      padding:10px 12px;white-space:pre-wrap;flex:1;width:100%
    }
    .modPromptInput .aside{font-style:italic;color:rgba(231,236,255,.75)}
    .inlineHalf{display:flex;gap:8px;flex:1;width:100%}
    .inlineHalf button{flex:1}
    
    @media (min-width:920px){
      .row{flex-direction:row}
      .col{min-width:280px}
      .topbar{flex-direction:row;align-items:center;justify-content:space-between;gap:10px}
    }
    .dead{color:rgba(255,255,255,.6);border-color:rgba(255,91,110,.35);background:rgba(255,91,110,.08)}
    .dead .name{ text-decoration:line-through }
    .mini{font-size:12px;color:var(--muted)}
    .hr{height:1px;background:rgba(255,255,255,.08);margin:10px 0}
    .table{width:100%;border-collapse:separate;border-spacing:0 8px}
    .table td{padding:10px 12px;background:rgba(255,255,255,.04);border-top:1px solid rgba(255,255,255,.08);border-bottom:1px solid rgba(255,255,255,.08)}
    .table td:first-child{border-left:1px solid rgba(255,255,255,.08);border-radius:12px 0 0 12px}
    .table td:last-child{border-right:1px solid rgba(255,255,255,.08);border-radius:0 12px 12px 0}
    .disabledRow{opacity:.55}
    .menuBtn{padding:4px 8px;border-radius:8px}
    .menuWide{width:100%;border:none}
    .menuLink{background:transparent;border:none;padding:8px 0;text-align:left}
    .menuLink:hover{filter:none;text-decoration:underline}
    .menuIcon{display:inline-flex;flex-direction:column;gap:4px}
    .menuIcon span{display:block;width:18px;height:2px;background:var(--txt);border-radius:2px}
    .textareaWrap{position:relative}
    .clearBtn{
      position:absolute;top:6px;right:6px;width:24px;height:24px;
      border-radius:10px;display:flex;align-items:center;justify-content:center;
      padding:0
    }
    .sidePanel{
      position:fixed;top:0;right:0;height:100vh;width:min(320px,85vw);
      background:rgba(18,26,51,.98);border-left:1px solid rgba(255,255,255,.08);
      transform:translateX(100%);transition:transform .2s ease;z-index:30;padding:16px
    }
    .modal{
      position:fixed;inset:0;display:flex;align-items:center;justify-content:center;
      opacity:0;pointer-events:none;transition:opacity .2s ease;z-index:40;padding:16px
    }
    .modal.show{opacity:1;pointer-events:auto}
    .modal .card{max-width:320px;width:100%;max-height:80vh;display:flex;flex-direction:column}
    .modalBody{overflow:auto;max-height:60vh}
    .modalActions{display:flex;gap:8px;justify-content:flex-end}
    .modal .card .confirmBtn{
      background:#f2f4ff;color:#0b1020;border:none;padding:10px 12px;border-radius:12px;
      min-width:96px;font-weight:600
    }
    .modal .card .bigMsg{font-size:20px;font-weight:700;white-space:pre-line;text-align:center}
    .modal .card .cancelBtn{
      background:transparent;border:1px solid rgba(255,255,255,.12);padding:10px 12px;border-radius:12px
    }
    .sidePanel.open{transform:translateX(0)}
    .overlay{
      position:fixed;inset:0;background:#000;
      opacity:0;pointer-events:none;transition:opacity .2s ease;z-index:25
    }
    .overlay.show{opacity:1;pointer-events:auto}
    .qty{display:flex;align-items:center;justify-content:flex-end;gap:8px}
    .qty button{padding:6px 10px;border-radius:10px}
    .log{white-space:pre-wrap;background:#0a1026;border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:10px 12px;min-height:120px;max-height:320px;overflow:auto}
    .ok{color:var(--good)} .bad{color:var(--bad)} .warn{color:var(--warn)} .other{color:var(--warn)}
    .roleRow{display:grid;grid-template-columns: 1.2fr 1fr; gap:10px; align-items:center; padding:4px 8px; border:1px solid rgba(255,255,255,.08); border-radius:14px; background:rgba(255,255,255,.04)}
    .roleSummaryCols{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .summaryTitle{font-weight:700;margin-bottom:6px}
    .summaryList{white-space:pre-wrap}
    .roleRow > div{justify-self:start;text-align:left}
    .roleRow > div:last-child{justify-self:end;text-align:right}
    .roleCounts{display:grid;grid-template-columns:repeat(2,1fr);gap:10px}
    .kpi{padding:10px 12px;border:1px solid rgba(255,255,255,.08);border-radius:14px;background:rgba(255,255,255,.04)}
    .kpi b{display:block;font-size:14px;color:var(--txt)}
    .disabledSection{opacity:.5;border-color:rgba(255,91,110,.35)}
  </style>
</head>
<body>
<header>
  <h1>Werewolf Moderator</h1>
  <button id="menuBtn" class="secondary menuBtn" aria-label="Menu">
    <span class="menuIcon"><span></span><span></span><span></span></span>
  </button>
</header>

<div class="wrap">

  <!-- SCREEN 1 -->
  <section id="s1" class="screen active">
    <div class="topbar">
      <div class="screenTitle">Setup</div>
    </div>

    <div class="row">
      <div class="col">
        <div class="card">
          <label class="mini">Player in seating order — one per line</label>
          <div class="mini" style="margin-top:4px">Current: <b id="playersCount">10</b> players</div>
          <div style="height:8px"></div>
          <div class="textareaWrap">
            <textarea id="playersTextarea" spellcheck="false"></textarea>
            <button id="clearPlayersBtn" class="secondary clearBtn" title="Clear">✕</button>
          </div>
          <div class="hr"></div>
          <div class="row">
            <button id="playBtn">Next</button>
          </div>
        </div>
      </div>

      <div class="col">
        <div id="resumeCard" class="card" style="margin-top:12px;display:none">
          <div class="row">
            <button id="resumeBtn" class="good">Resume last game</button>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- SCREEN 2 -->
  <section id="s2" class="screen">
    <div class="topbar">
      <div class="screenTitle">Role configuration</div>
      <div class="rolesTotalText"><b id="rolesTotal2">0</b> / <b id="rolesCap2">10</b></div>
    </div>

    <div class="card">
      <div class="${witchAlive ? "" : "disabledSection"}">
      <div class="row">
        <div class="col ${lifeDisabled ? "disabledSection" : ""}">
          <div class="badge bad">Evil side (<span id="evilCount">0</span>)</div>
          <table class="table" id="roleTableEvil"></table>
        </div>
        <div class="col ${lifeDisabled ? "disabledSection" : ""}">
          <div class="badge">Good side (<span id="goodCount">0</span>)</div>
          <table class="table" id="roleTableGood"></table>
          <div class="hr"></div>
          <div class="badge">Others (<span id="otherCount">0</span>)</div>
          <table class="table" id="roleTableOther"></table>
        </div>
      </div>

      <div class="hr"></div>
      <div class="row" style="margin-top:8px">
        <button id="roleSummaryBtnConfig" class="good menuWide">Role Summary</button>
      </div>
      <div class="inlineHalf" style="margin-top:8px">
        <button id="backToS1Btn" class="secondary">Back</button>
        <button id="toAssignRolesBtn">Next</button>
      </div>
    </div>
  </section>

  <!-- SCREEN 2.5 -->
  <section id="s25" class="screen">
    <div class="topbar">
      <div class="screenTitle">Role assignment</div>
    </div>

    <div class="row">
      <div class="col">
        <div class="card">
          <div id="assignRolesList" style="display:flex;flex-direction:column;gap:10px"></div>
        </div>
      </div>

      <div class="col">
        <div class="card">
          <div id="remainingBlock">
            <div class="badge">Remaining counts</div>
            <div class="hr"></div>
            <div class="roleCounts" id="remainingCounts"></div>
            <div class="hr"></div>
            <div class="mini" id="assignValidation"></div>
            <div class="hr"></div>
          </div>
          <div class="row" style="justify-content:space-between">
            <button id="startGameBtn">Start game</button>
          </div>
          <div class="row" style="margin-top:8px">
            <button id="roleSummaryBtn" class="good menuWide">Role Summary</button>
          </div>
          <div class="row" style="margin-top:8px">
            <button id="getRevealLinkBtn" class="menuWide warn">Get Link to Reveal All Roles</button>
          </div>
          <div class="row" style="margin-top:8px">
            <div class="inlineHalf">
              <button id="autoFillRolesBtn" class="good btnMatch">Randomly assign</button>
              <button id="clearRolesBtn" class="danger btnMatch">Clear</button>
            </div>
          </div>
          <div class="row" style="margin-top:8px">
            <button id="backToRoleConfigBtn" class="secondary">Back</button>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- SCREEN 3 -->
  <section id="s3" class="screen">
    <div class="topbar">
      <div class="screenTitle" id="nightTitle">Night</div>
    </div>

    <div class="row">
      <div class="col">
        <div class="card">
          <div class="row" style="align-items:center;justify-content:space-between">
            <div class="mini" style="font-size:14px">Night <b id="nightNumber">1</b> · Living <b id="livingCount">0</b></div>
            <div class="nightNav">
              <button id="nightPrevBtn" class="secondary btnMatch">Previous role</button>
              <button id="nightNextBtn" class="btnMatch">Next role</button>
            </div>
          </div>

          <div class="mini" style="margin-top:8px">Moderator script (skip the text in parenthesis)</div>
          <div class="modPromptRow" style="margin-top:6px">
            <div class="modPromptIcon" aria-hidden="true">
              <svg viewBox="0 0 24 24" width="18" height="18" role="img" focusable="false">
                <path fill="currentColor" d="M12 14a3 3 0 0 0 3-3V5a3 3 0 0 0-6 0v6a3 3 0 0 0 3 3zm5-3a5 5 0 0 1-10 0H5a7 7 0 0 0 6 6.92V20H9v2h6v-2h-2v-2.08A7 7 0 0 0 19 11z"/>
              </svg>
            </div>
            <div id="nightPrompt" class="modPromptInput"></div>
          </div>

          <div class="hr"></div>
          <div id="nightPanel"></div>
        </div>
      </div>

      <div class="col">
        <div class="card">
          <div class="row">
            <button id="toDayBtn" class="good">End this night</button>
            <button id="toManualBtn" class="secondary">Manual kill/revive</button>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- SCREEN 4 -->
  <section id="s4" class="screen">
    <div class="topbar">
      <div class="screenTitle" id="dayTitle">Day 1</div>
      <div id="dayTimerText" class="dayTimerText">00:00</div>
    </div>

    <div class="row">
      <div class="col">
        <div class="card">
          <div class="badge">Announcements</div>
          <div class="hr"></div>
          <div id="dayAnnouncements" class="log"></div>
          <div class="hr"></div>
          <div class="hr"></div>
          <div class="row">
            <button id="toVoteBtn">Vote</button>
            <button id="toNextNightBtn" class="secondary">Go to Next Night</button>
          </div>
        </div>
      </div>

      <div class="col">
        <div class="card">
          <div class="badge">Last night logs</div>
          <div class="hr"></div>
          <div id="nightLog" class="log"></div>
        </div>
      </div>
    </div>
  </section>

  <!-- SCREEN 5 -->
  <section id="s5" class="screen">
    <div class="topbar">
      <div class="screenTitle">Lynch</div>
      <div id="lynchTimerText" class="lynchTimerText">00:00</div>
    </div>

    <div class="row">
      <div class="col">
        <div class="card">
          <div class="badge">Pick a player</div>
          <div class="hr"></div>
          <div id="playersGridVote" class="grid"></div>
          <div class="hr"></div>

          <div class="mini">Selected: <b id="voteSelectedLabel">—</b></div>
          <div class="hr"></div>

          <div class="hr"></div>
          <div class="row">
            <button id="killByVoteBtn" class="danger">Lynch</button>
            <button id="spareByVoteBtn" class="good">Spare</button>
          </div>

          <div class="hr"></div>
          <button id="backToDayBtn" class="secondary">Back</button>
        </div>
      </div>

      <div class="col"></div>
    </div>
  </section>

  <!-- SCREEN 6 -->
  <section id="s6" class="screen">
    <div class="topbar">
      <div class="screenTitle">Manual kill/revive (admin)</div>
      <div class="pill"><span class="mini">Click to toggle</span></div>
    </div>

    <div class="card">
      <div id="playersGridManual" class="grid"></div>
      <div class="hr"></div>
      <div class="row">
        <button id="backFromManualBtn" class="secondary">Back</button>
      </div>
    </div>
  </section>

  <!-- SCREEN 7 -->
  <section id="s7" class="screen">
    <div class="topbar">
      <div class="screenTitle">Winner</div>
    </div>

    <div class="card">
      <h2 id="winnerTitle" style="margin:0 0 10px 0"></h2>
      <div id="winnerDetails" class="log"></div>
      <div class="hr"></div>
      <div class="row">
        <button id="restartBtn" class="secondary">Reset game</button>
        <button id="backToDayFromWinBtn">Back to Day</button>
      </div>
    </div>
  </section>

  <!-- SCREEN 8 -->
  <section id="s8" class="screen">
    <div class="topbar">
      <div class="screenTitle">Role Reveal</div>
    </div>

    <div class="row">
      <div class="col">
        <div class="card">
          <div class="mini">Tap a player name to reveal their role.</div>
          <div class="hr"></div>
          <button id="revealAllBtn" class="danger menuWide">Reveal All Roles!!!</button>
          <div class="row" style="margin-top:8px">
            <button id="revealSummaryBtn" class="good menuWide">Role Summary</button>
          </div>
          <div class="hr"></div>
          <div id="revealList" class="grid"></div>
        </div>
      </div>
    </div>
  </section>

</div>

<div id="overlay" class="overlay"></div>
<aside id="sidePanel" class="sidePanel">
  <div class="mini">Menu</div>
  <div class="hr"></div>
  <button id="resetGameBtn" class="secondary menuWide menuLink">New game</button>
  <button id="aboutBtn" class="secondary menuWide menuLink">About me</button>
</aside>

<div id="modalOverlay" class="overlay"></div>
<div id="appModal" class="modal">
  <div class="card">
    <div id="modalTitle" class="mini">Notice</div>
    <div class="hr"></div>
    <div class="modalBody">
      <div id="modalMessage" class="mini"></div>
    </div>
    <div class="hr"></div>
    <div class="modalActions">
      <button id="modalCancelBtn" class="cancelBtn">Cancel</button>
      <button id="modalConfirmBtn" class="confirmBtn">OK</button>
    </div>
  </div>
</div>

<script>
(() => {
  // ----- State -----
  const ROLE = {
    WEREWOLF: "Werewolf",
    SORCERESS: "Sorceress",
    WOLFCUB: "Wolf cub",
    FRUIT_WOLF: "Fruit Wolf",
    SEER: "Seer",
    APPRENTICE_SEER: "Apprentice Seer",
    MASON: "Mason",
    BODYGUARD: "Bodyguard",
    HUNTER: "Hunter",
    WITCH: "Witch",
    DISEASED: "Diseased",
    TOUGH_GUY: "Tough Guy",
    PI: "P.I.",
    MAYOR: "Mayor",
    CUPID: "Cupid",
    VILLAGER: "Villager",
    SPELLCASTER: "Spellcaster",
    PRIEST: "Priest",
    DOPPELGANGER: "Doppelganger",
    DIRE_WOLF: "Dire Wolf",
    SOBER: "Tanner",
    IDIOT: "Idiot",
    TROUBLEMAKER: "Troublemaker",
    PACIFIST: "Pacifist",
  };

  const SIDE = { EVIL: "evil", GOOD: "good", OTHER: "other" };

  const roleMeta = {
    [ROLE.WEREWOLF]: { side: SIDE.EVIL, note: "Bite at night" },
    [ROLE.SORCERESS]: { side: SIDE.EVIL, note: "Each night, looks for the Seer" },
    [ROLE.WOLFCUB]:  { side: SIDE.EVIL, note: "If dies, next night wolves bite 2" },
    [ROLE.FRUIT_WOLF]: { side: SIDE.EVIL, note: "Cannot bite if only Fruit Wolves remain" },
    [ROLE.SEER]:     { side: SIDE.GOOD, note: "Reveal good/evil" },
    [ROLE.APPRENTICE_SEER]: { side: SIDE.GOOD, note: "Reveals good/evil after Seer dies" },
    [ROLE.MASON]:    { side: SIDE.GOOD, note: "First night: learn other Masons" },
    [ROLE.BODYGUARD]:{ side: SIDE.GOOD, note: "Protect 1 from bites" },
    [ROLE.HUNTER]:   { side: SIDE.GOOD, note: "Choose a target each night. The marked target dies if the Hunter dies." },
    [ROLE.WITCH]:    { side: SIDE.GOOD, note: "1 save potion + 1 kill potion" },
    [ROLE.DISEASED]: { side: SIDE.GOOD, note: "If eaten by wolves, they skip feeding next night" },
    [ROLE.TOUGH_GUY]:{ side: SIDE.GOOD, note: "If bitten, survives until next day" },
    [ROLE.PI]:       { side: SIDE.GOOD, note: "Once per game: check 3 players for Werewolf" },
    [ROLE.MAYOR]:    { side: SIDE.GOOD, note: "Vote counts twice when lynching" },
    [ROLE.CUPID]:    { side: SIDE.GOOD, note: "First night: choose 2 players to become a couple" },
    [ROLE.SPELLCASTER]: { side: SIDE.GOOD, note: "Each night: choose a player to be silent next day" },
    [ROLE.PRIEST]:   { side: SIDE.GOOD, note: "Once per game: protect 1 player from night death" },
    [ROLE.DOPPELGANGER]: { side: SIDE.GOOD, note: "First night: choose a player. If they die, you become that role" },
    [ROLE.DIRE_WOLF]: { side: SIDE.EVIL, note: "First night: choose a player. If they die, Dire Wolf dies too" },
    [ROLE.VILLAGER]: { side: SIDE.GOOD, note: "No power" },
    [ROLE.SOBER]:    { side: SIDE.OTHER, note: "If lynched, wins" },
    [ROLE.IDIOT]:    { side: SIDE.GOOD, note: "Always votes to lynch" },
    [ROLE.TROUBLEMAKER]: { side: SIDE.GOOD, note: "Once per game: allow 2 lynches in a day" },
    [ROLE.PACIFIST]: { side: SIDE.GOOD, note: "Always votes to spare" },
  };

  const defaultRoles = {
    [ROLE.WEREWOLF]: 1,
    [ROLE.SORCERESS]: 0,
    [ROLE.WOLFCUB]: 1,
    [ROLE.FRUIT_WOLF]: 0,
    [ROLE.SEER]: 1,
    [ROLE.APPRENTICE_SEER]: 0,
    [ROLE.MASON]: 0,
    [ROLE.BODYGUARD]: 1,
    [ROLE.HUNTER]: 1,
    [ROLE.WITCH]: 1,
    [ROLE.DISEASED]: 0,
    [ROLE.TOUGH_GUY]: 0,
    [ROLE.PI]: 0,
    [ROLE.MAYOR]: 0,
    [ROLE.CUPID]: 0,
    [ROLE.PACIFIST]: 0,
    [ROLE.SPELLCASTER]: 0,
    [ROLE.PRIEST]: 0,
    [ROLE.DOPPELGANGER]: 0,
    [ROLE.DIRE_WOLF]: 0,
    [ROLE.VILLAGER]: 2,
    [ROLE.SOBER]: 0,
    [ROLE.IDIOT]: 0,
    [ROLE.TROUBLEMAKER]: 0,
  };

  const state = {
    players: [], // {id, name, alive, role}
    playerCount: 10,
    roles: { ...defaultRoles },
    gameStarted: false,

    night: {
      number: 1,
      stepIndex: 0,
      steps: [],
      wolfSelectedIds: [],
      bites: [],
      sorceressInspectId: null,
      sorceressResult: null,
      seerInspectId: null,
      seerResult: null,
      apprenticeInspectId: null,
      apprenticeResult: null,
      piSelectedIds: [],
      piResult: null,
      piChecked: false,
      piSecondUse: false,
      cupidSelectedIds: [],
      cupidConfirmed: false,
      spellcasterTargetId: null,
      priestProtectId: null,
      priestUsed: false,
      bodyguardId: null,
      witchSaveUsed: false,
      witchKillUsed: false,
      witchSaved: false,
      witchSaveId: null,
      witchKillId: null,
      hunterMarkId: null,
      hunterDied: false,
    },

    day: {
      announcements: [],
      lastNightLog: [],
      dayDeaths: [],
      lastNightDeaths: [],
      wolfCubDiedLastDay: false,
      pendingHunterMarkId: null,
      lynchCount: 0,
      lynchWarned: false,
      lastBodyguardId: null,
      skipWolfBiteNextNight: false,
      troublemakerUsed: false,
      troublemakerActiveToday: false,
      troublemakerPendingNextDay: false,
      troublemakerLastUseNight: null,
      pendingToughGuyId: null,
      pendingToughGuyNight: null,
      piUses: 0,
      piLastUseNight: null,
      witchSaveLastUseNight: null,
      witchKillLastUseNight: null,
      history: [],
      coupleIds: null,
      pendingCoupleId: null,
      silencedId: null,
      priestLastUseNight: null,
      doppelgangerTargetId: null,
      doppelgangerPendingRole: null,
      doppelgangerRole: null,
      direWolfTargetId: null,
      pendingDireWolfId: null,
      pendingDireWolfNight: null,
    },

    vote: { selectedId: null, timer: 0, interval: null },
    timers: { day: 0, dayInterval: null },

    winner: null,
  };

  // ----- Helpers -----
  const $ = (id) => document.getElementById(id);
  const STORAGE_KEY = "werewolfModeratorState.v1";
  let saveSuppressed = false;

  function getDisplayRole(p){
    if (!p || !p.role) return "?";
    if (p.baseRole === ROLE.DOPPELGANGER && p.role !== ROLE.DOPPELGANGER){
      return `Doppelganger (${p.role})`;
    }
    return p.role;
  }

  function getDoppelgangerPlayer(){
    return state.players.find(p => p.baseRole === ROLE.DOPPELGANGER || p.role === ROLE.DOPPELGANGER) || null;
  }

  function isRoleEffectivelyAlive(role){
    if (isRoleAlive(role)) return true;
    return state.players.some(p => p.alive && p.baseRole === ROLE.DOPPELGANGER && p.role === role);
  }

  function markDoppelgangerTargetDeath(p){
    if (!p) return;
    if (state.day.doppelgangerTargetId === p.id && !state.day.doppelgangerPendingRole && !state.day.doppelgangerRole){
      state.day.doppelgangerPendingRole = p.role;
    }
  }

  function resetRoleUsageForDoppel(role){
    if (!role) return;
    if (role === ROLE.WITCH){
      state.night.witchSaveUsed = false;
      state.night.witchKillUsed = false;
      state.night.witchSaveId = null;
      state.night.witchKillId = null;
      state.day.witchSaveLastUseNight = null;
      state.day.witchKillLastUseNight = null;
    }
    if (role === ROLE.PRIEST){
      state.day.priestLastUseNight = null;
      state.night.priestProtectId = null;
    }
    if (role === ROLE.PI){
      state.day.piUses = 0;
      state.day.piLastUseNight = null;
      state.night.piSelectedIds = [];
      state.night.piResult = null;
      state.night.piChecked = false;
      state.night.piSecondUse = false;
    }
    if (role === ROLE.TROUBLEMAKER){
      state.day.troublemakerUsed = false;
      state.day.troublemakerLastUseNight = null;
      state.day.troublemakerPendingNextDay = false;
      state.day.troublemakerActiveToday = false;
    }
    if (role === ROLE.HUNTER){
      state.night.hunterMarkId = null;
      state.day.pendingHunterMarkId = null;
    }
    if (role === ROLE.BODYGUARD){
      state.day.lastBodyguardId = null;
      state.night.bodyguardId = null;
    }
    if (role === ROLE.SPELLCASTER){
      state.night.spellcasterTargetId = null;
      state.day.silencedId = null;
    }
    if (role === ROLE.SEER){
      state.night.seerInspectId = null;
      state.night.seerResult = null;
    }
    if (role === ROLE.SORCERESS){
      state.night.sorceressInspectId = null;
      state.night.sorceressResult = null;
    }
    if (role === ROLE.APPRENTICE_SEER){
      state.night.apprenticeInspectId = null;
      state.night.apprenticeResult = null;
    }
  }

  function applyDoppelgangerPendingRole(){
    if (!state.day.doppelgangerPendingRole) return;
    const dg = getDoppelgangerPlayer();
    if (!dg || !dg.alive){
      state.day.doppelgangerPendingRole = null;
      return;
    }
    const role = state.day.doppelgangerPendingRole;
    dg.role = role;
    dg.baseRole = ROLE.DOPPELGANGER;
    state.day.doppelgangerRole = role;
    state.day.doppelgangerPendingRole = null;
    resetRoleUsageForDoppel(role);
    return role;
  }

  function snapshotState(){
    return JSON.parse(JSON.stringify({
      players: state.players,
      playerCount: state.playerCount,
      roles: state.roles,
      gameStarted: state.gameStarted,
      night: {
        number: state.night.number,
        stepIndex: state.night.stepIndex,
        wolfSelectedIds: state.night.wolfSelectedIds,
        bites: state.night.bites,
        sorceressInspectId: state.night.sorceressInspectId,
        sorceressResult: state.night.sorceressResult,
        seerInspectId: state.night.seerInspectId,
        seerResult: state.night.seerResult,
        apprenticeInspectId: state.night.apprenticeInspectId,
        apprenticeResult: state.night.apprenticeResult,
        piSelectedIds: state.night.piSelectedIds,
        piResult: state.night.piResult,
        piChecked: state.night.piChecked,
        piSecondUse: state.night.piSecondUse,
        cupidSelectedIds: state.night.cupidSelectedIds,
        cupidConfirmed: state.night.cupidConfirmed,
        spellcasterTargetId: state.night.spellcasterTargetId,
        priestProtectId: state.night.priestProtectId,
        priestUsed: state.night.priestUsed,
        bodyguardId: state.night.bodyguardId,
        witchSaveUsed: state.night.witchSaveUsed,
        witchKillUsed: state.night.witchKillUsed,
        witchSaved: state.night.witchSaved,
        witchSaveId: state.night.witchSaveId,
        witchKillId: state.night.witchKillId,
        hunterMarkId: state.night.hunterMarkId,
        hunterDied: state.night.hunterDied,
      },
      day: state.day,
      vote: { selectedId: state.vote.selectedId, timer: state.vote.timer },
      timers: { day: state.timers.day },
      winner: state.winner,
    }));
  }

  function saveState(){
    if (saveSuppressed) return;
    try {
      const activeScreen = document.querySelector(".screen.active")?.id || "s1";
      const payload = { activeScreen, snapshot: snapshotState() };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
    } catch {}
  }

  function canOpenVoteNow(){
    return (state.day.lynchCount === 0) || (state.day.troublemakerActiveToday && state.day.lynchCount === 1);
  }

  function updateDayActions(){
    const btn = $("toVoteBtn");
    if (!btn) return;
    const hardDisabled = state.day.lynchCount >= 2;
    const canOpen = canOpenVoteNow();
    btn.classList.toggle("disabledLike", !canOpen || hardDisabled);
  }

  function loadSavedState(){
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!parsed || !parsed.snapshot) return null;
      return parsed;
    } catch {
      return null;
    }
  }

  function clearSavedState(){
    try { localStorage.removeItem(STORAGE_KEY); } catch {}
  }

  function showScreen(n) {
    const nextId = (typeof n === "string" ? n : "s"+n);
    const prevId = document.querySelector(".screen.active")?.id || null;

    if (prevId === "s4") stopDayTimer();
    if (prevId === "s5") stopVoteTimer();

    for (const el of document.querySelectorAll(".screen")) el.classList.remove("active");
    $(nextId).classList.add("active");
    window.scrollTo({ top: 0, left: 0, behavior: "instant" });

    if (nextId === "s4"){
      state.timers.day = 0;
      $("dayTimerText").textContent = fmtTime(0);
      const dayTitle = $("dayTitle");
      if (dayTitle) dayTitle.textContent = `Day ${state.night.number}`;
      startDayTimer();
      updateDayActions();
    }
    if (nextId === "s2"){
      trimRolesToPlayerCount();
      renderRoleTables();
    }
    if (nextId === "s5"){
      state.vote.timer = 0;
      $("lynchTimerText").textContent = fmtTime(0);
      startVoteTimer();
    }
    updateQuickStatus();
    if (!saveSuppressed) saveState();
  }

  function showModal({title="Notice", message="", confirmText="OK", cancelText=null, bigMessage=false, html=false} = {}){
    return new Promise(resolve => {
      const modal = $("appModal");
      const overlay = $("modalOverlay");
      const titleEl = $("modalTitle");
      const msgEl = $("modalMessage");
      const okBtn = $("modalConfirmBtn");
      const cancelBtn = $("modalCancelBtn");

      titleEl.textContent = title;
      if (html) msgEl.innerHTML = message;
      else msgEl.textContent = message;
      msgEl.classList.toggle("bigMsg", !!bigMessage);
      okBtn.textContent = confirmText;
      if (cancelText){
        cancelBtn.textContent = cancelText;
        cancelBtn.style.display = "";
      } else {
        cancelBtn.style.display = "none";
      }

      const close = (result) => {
        modal.classList.remove("show");
        overlay.classList.remove("show");
        okBtn.onclick = null;
        cancelBtn.onclick = null;
        overlay.onclick = null;
        resolve(result);
      };

      okBtn.onclick = () => close(true);
      cancelBtn.onclick = () => close(false);
      overlay.onclick = () => cancelText ? close(false) : close(true);

      modal.classList.add("show");
      overlay.classList.add("show");
    });
  }

  const alertModal = (message, title="Notice") => showModal({title, message, confirmText:"OK"});
  const confirmModal = (message, title="Confirm") => showModal({title, message, confirmText:"Yes", cancelText:"No"});
  const bigModal = (message, title="") => showModal({title, message, confirmText:"OK", bigMessage:true});

  function applySnapshot(snap){
    if (!snap) return;
    state.players = snap.players || [];
    state.players.forEach(p => {
      if (p.role) p.role = normalizeRole(p.role);
      if (!p.role) p.role = ROLE.VILLAGER;
      if (p.baseRole == null){
        p.baseRole = (p.role === ROLE.DOPPELGANGER) ? ROLE.DOPPELGANGER : null;
      }
    });
    state.playerCount = snap.playerCount || state.players.length || 0;
    const cleanedRoles = { ...defaultRoles, ...(snap.roles || {}) };
    for (const key of Object.keys(cleanedRoles)){
      if (!roleMeta[key]) delete cleanedRoles[key];
    }
    state.roles = cleanedRoles;
    state.gameStarted = !!snap.gameStarted;

    const n = snap.night || {};
    state.night.number = n.number ?? 1;
    state.night.stepIndex = n.stepIndex ?? 0;
    state.night.wolfSelectedIds = n.wolfSelectedIds || [];
    state.night.bites = n.bites || [];
    state.night.sorceressInspectId = n.sorceressInspectId ?? null;
    state.night.sorceressResult = n.sorceressResult ?? null;
    state.night.seerInspectId = n.seerInspectId ?? null;
    state.night.seerResult = n.seerResult ?? null;
    state.night.apprenticeInspectId = n.apprenticeInspectId ?? null;
    state.night.apprenticeResult = n.apprenticeResult ?? null;
    state.night.piSelectedIds = n.piSelectedIds || [];
    state.night.piResult = n.piResult ?? null;
    state.night.piChecked = !!n.piChecked;
    state.night.piSecondUse = !!n.piSecondUse;
    state.night.cupidSelectedIds = n.cupidSelectedIds || [];
    state.night.cupidConfirmed = !!n.cupidConfirmed;
    state.night.spellcasterTargetId = n.spellcasterTargetId ?? null;
    state.night.priestProtectId = n.priestProtectId ?? null;
    state.night.priestUsed = !!n.priestUsed;
    state.night.bodyguardId = n.bodyguardId ?? null;
    state.night.witchSaveUsed = !!n.witchSaveUsed;
    state.night.witchKillUsed = !!n.witchKillUsed;
    state.night.witchSaved = !!n.witchSaved;
    state.night.witchSaveId = n.witchSaveId ?? null;
    state.night.witchKillId = n.witchKillId ?? null;
    state.night.hunterMarkId = n.hunterMarkId ?? null;
    state.night.hunterDied = !!n.hunterDied;

    state.day = {
      announcements: [],
      lastNightLog: [],
      dayDeaths: [],
      wolfCubDiedLastDay: false,
      pendingHunterMarkId: null,
      lynchCount: 0,
      lynchWarned: false,
      lastBodyguardId: null,
      skipWolfBiteNextNight: false,
      troublemakerUsed: false,
      troublemakerActiveToday: false,
      troublemakerPendingNextDay: false,
      pendingToughGuyId: null,
      pendingToughGuyNight: null,
      piUses: 0,
      piLastUseNight: null,
      witchSaveLastUseNight: null,
      witchKillLastUseNight: null,
      history: [],
      coupleIds: null,
      pendingCoupleId: null,
      silencedId: null,
      priestLastUseNight: null,
      ...(snap.day || {})
    };
    if (state.day.priestLastUseNight == null) state.day.priestLastUseNight = null;
    if (state.day.troublemakerLastUseNight == null) state.day.troublemakerLastUseNight = null;
    if (state.day.doppelgangerTargetId == null) state.day.doppelgangerTargetId = null;
    if (state.day.doppelgangerPendingRole == null) state.day.doppelgangerPendingRole = null;
    if (state.day.doppelgangerRole == null) state.day.doppelgangerRole = null;
    if (state.day.direWolfTargetId == null) state.day.direWolfTargetId = null;
    if (state.day.pendingDireWolfId == null) state.day.pendingDireWolfId = null;
    if (state.day.pendingDireWolfNight == null) state.day.pendingDireWolfNight = null;

    state.vote.selectedId = snap.vote?.selectedId ?? null;
    state.vote.timer = snap.vote?.timer ?? 0;
    state.vote.interval = null;
    state.timers.day = snap.timers?.day ?? 0;
    state.timers.dayInterval = null;
    state.winner = snap.winner ?? null;

    state.night.steps = buildNightSteps();
    state.night.stepIndex = clamp(state.night.stepIndex, 0, Math.max(0, state.night.steps.length-1));

    state.players.forEach((p, idx) => {
      if (!p.id) p.id = idx+1;
      if (!p.name) p.name = `Player ${p.id}`;
      if (p.alive == null) p.alive = true;
    });
  }

  function restoreUIForScreen(screenId){
    renderPlayersTextarea();
    renderRoleTables();
    updateQuickStatus();

    if (screenId === "s2"){
      showScreen(2);
      return;
    }
    if (screenId === "s25"){
      renderAssignRoles();
      showScreen("s25");
      return;
    }
    if (screenId === "s3"){
      renderNight();
      showScreen(3);
      return;
    }
    if (screenId === "s4"){
      $("dayAnnouncements").textContent = state.day.announcements.join("\n");
      $("nightLog").textContent = state.day.lastNightLog.join("\n");
      showScreen(4);
      stopDayTimer();
      $("dayTimerText").textContent = fmtTime(state.timers.day);
      return;
    }
    if (screenId === "s5"){
      renderVote();
      showScreen(5);
      stopVoteTimer();
      $("lynchTimerText").textContent = fmtTime(state.vote.timer);
      return;
    }
    if (screenId === "s6"){
      renderManual();
      showScreen(6);
      return;
    }
    if (screenId === "s7"){
      if (state.winner){
        $("winnerTitle").textContent = state.winner.title || "";
        $("winnerDetails").textContent = (state.winner.details || []).join("\n");
      }
      showScreen(7);
      return;
    }
    showScreen(1);
  }

  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
  function roleTotal(){ return Object.values(state.roles).reduce((a,b)=>a+b,0); }
  function livingPlayers(){ return state.players.filter(p => p.alive); }

  function fmtTime(sec){
    sec = Math.max(0, sec|0);
    const m = String(Math.floor(sec/60)).padStart(2,"0");
    const s = String(sec%60).padStart(2,"0");
    return `${m}:${s}`;
  }

  function isEvilRole(role){ return roleMeta[role]?.side === SIDE.EVIL; }
  function labelPlayer(id){
    if (!id) return "";
    const p = state.players.find(x => x.id === id);
    return p ? `${p.name}` : "";
  }
  function labelPlayerWithRole(id){
    if (!id) return "";
    const p = state.players.find(x => x.id === id);
    return p ? `${p.name} (${getDisplayRole(p)})` : "";
  }

  function trimRolesToPlayerCount(){
    let excess = roleTotal() - state.playerCount;
    if (excess <= 0) return;
    const goodRoles = [ROLE.SEER, ROLE.APPRENTICE_SEER, ROLE.MASON, ROLE.BODYGUARD, ROLE.HUNTER, ROLE.WITCH, ROLE.DISEASED, ROLE.TOUGH_GUY, ROLE.PI, ROLE.MAYOR, ROLE.CUPID, ROLE.DOPPELGANGER, ROLE.SPELLCASTER, ROLE.PRIEST, ROLE.IDIOT, ROLE.PACIFIST, ROLE.TROUBLEMAKER, ROLE.VILLAGER];
    const evilRoles = [ROLE.WEREWOLF, ROLE.SORCERESS, ROLE.WOLFCUB, ROLE.DIRE_WOLF, ROLE.FRUIT_WOLF];
    const otherRoles = [ROLE.SOBER];
    const order = [...goodRoles, ...evilRoles, ...otherRoles];
    for (const r of order){
      if (excess <= 0) break;
      while (state.roles[r] > 0 && excess > 0){
        state.roles[r]--;
        excess--;
      }
    }
  }
  function getOutOfUsageWarning(margin="margin-top:6px"){
    return `<div class="mini warn" style="${margin}">Out of uses.</div>`;
  }

  const ROLE_ORDER = [
    ROLE.WEREWOLF, ROLE.SORCERESS, ROLE.WOLFCUB, ROLE.DIRE_WOLF, ROLE.FRUIT_WOLF,
    ROLE.SEER, ROLE.APPRENTICE_SEER, ROLE.MASON, ROLE.BODYGUARD, ROLE.HUNTER,
    ROLE.WITCH, ROLE.DISEASED, ROLE.TOUGH_GUY, ROLE.PI, ROLE.MAYOR, ROLE.CUPID,
    ROLE.SPELLCASTER, ROLE.PRIEST, ROLE.DOPPELGANGER, ROLE.IDIOT, ROLE.PACIFIST,
    ROLE.TROUBLEMAKER, ROLE.SOBER, ROLE.VILLAGER
  ];
  const roleToId = (role) => {
    const idx = ROLE_ORDER.indexOf(role);
    return idx >= 0 ? idx+1 : 0;
  };
  const idToRole = (id) => ROLE_ORDER[(id|0)-1] || "—";

  function toB64Url(bytes){
    let bin = "";
    bytes.forEach(b => bin += String.fromCharCode(b));
    return btoa(bin).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"");
  }
  function fromB64Url(str){
    const pad = str.length % 4 === 0 ? "" : "=".repeat(4 - (str.length % 4));
    const b64 = str.replace(/-/g,"+").replace(/_/g,"/") + pad;
    const bin = atob(b64);
    return Uint8Array.from(bin, c => c.charCodeAt(0));
  }
  async function encryptRoomInfo(data){
    const enc = new TextEncoder();
    const keyBytes = crypto.getRandomValues(new Uint8Array(16));
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const key = await crypto.subtle.importKey("raw", keyBytes, "AES-GCM", false, ["encrypt"]);
    const cipher = await crypto.subtle.encrypt({name:"AES-GCM", iv}, key, enc.encode(JSON.stringify(data)));
    return `${toB64Url(keyBytes)}.${toB64Url(iv)}.${toB64Url(new Uint8Array(cipher))}`;
  }
  async function decryptRoomInfo(token){
    const [k, i, c] = (token || "").split(".");
    if (!k || !i || !c) return null;
    const keyBytes = fromB64Url(k);
    const iv = fromB64Url(i);
    const cipher = fromB64Url(c);
    const key = await crypto.subtle.importKey("raw", keyBytes, "AES-GCM", false, ["decrypt"]);
    const plain = await crypto.subtle.decrypt({name:"AES-GCM", iv}, key, cipher);
    const dec = new TextDecoder();
    return JSON.parse(dec.decode(plain));
  }
  function buildRevealUrl(token){
    const url = new URL(window.location.href);
    url.search = "";
    url.searchParams.set("RI", token);
    return url.toString();
  }
  function isRoleAlive(role){
    return state.players.some(p => p.alive && p.role === role);
  }
  function isWolfRole(role){
    return isEvilRole(role);
  }
  function normalizeRole(role){
    return roleMeta[role] ? role : ROLE.VILLAGER;
  }
  function aliveWolves(){
    return state.players.some(p => p.alive && isEvilRole(p.role));
  }
  function canWolvesBite(){
    return state.players.some(p => p.alive && isEvilRole(p.role) && p.role !== ROLE.FRUIT_WOLF);
  }

  function linesFromTextarea(){
    return $("playersTextarea").value.split("\n").map(s => s.trim()).filter(Boolean);
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }

  function updateQuickStatus(){
    const pc = $("playersCount"); if (pc) pc.textContent = state.playerCount;
    const rc = $("rolesCap"); if (rc) rc.textContent = state.playerCount;
    const rc2 = $("rolesCap2"); if (rc2) rc2.textContent = state.playerCount;
    const rt = $("rolesTotal"); if (rt) rt.textContent = roleTotal();
    const rt2 = $("rolesTotal2"); if (rt2) rt2.textContent = roleTotal();
    const active = document.querySelector(".screen.active")?.id || "s1";
    const phase =
      active === "s1" || active === "s2" || active === "s25" ? "Setup" :
      active === "s3" ? "Night" :
      active === "s4" ? "Day" :
      active === "s5" ? "Lynch" :
      active === "s6" ? "Admin" :
      active === "s7" ? "Winner" : "—";
    const phaseEl = $("phaseLabel"); if (phaseEl) phaseEl.textContent = phase;
  }

  // ----- Night steps -----
  function buildNightSteps(){
    const steps = [];
    if (state.roles[ROLE.DIRE_WOLF] > 0 && state.night.number === 1) steps.push("dire_wolf");
    if (state.roles[ROLE.DOPPELGANGER] > 0) steps.push("doppelganger");
    if (state.roles[ROLE.CUPID] > 0 && state.night.number === 1) steps.push("cupid");
    if (
      state.roles[ROLE.WEREWOLF] + state.roles[ROLE.WOLFCUB] +
      state.roles[ROLE.SORCERESS] + state.roles[ROLE.DIRE_WOLF] +
      state.roles[ROLE.FRUIT_WOLF] > 0
    ) steps.push("werewolf");
    if (state.roles[ROLE.SORCERESS] > 0) steps.push("sorceress");
    if (state.roles[ROLE.TROUBLEMAKER] > 0) steps.push("troublemaker");
    if (state.roles[ROLE.MASON] > 0 && state.night.number === 1) steps.push("mason");
    if (state.roles[ROLE.SEER] > 0) steps.push("seer");
    if (state.roles[ROLE.APPRENTICE_SEER] > 0) steps.push("apprentice_seer");
    if (state.day.coupleIds && state.day.coupleIds.length === 2 && state.night.number > 1) steps.push("couple");
    if (state.roles[ROLE.PI] > 0) steps.push("pi");
    if (state.roles[ROLE.SPELLCASTER] > 0) steps.push("spellcaster");
    if (state.roles[ROLE.PRIEST] > 0) steps.push("priest");
    if (state.roles[ROLE.BODYGUARD] > 0) steps.push("bodyguard");
    if (state.roles[ROLE.WITCH] > 0) steps.push("witch");
    if (state.roles[ROLE.HUNTER] > 0) steps.push("hunter");
    return steps;
  }

  function resetNightState({keepPotions=false} = {}){
    state.night.stepIndex = 0;
    state.night.steps = buildNightSteps();
    state.night.wolfSelectedIds = [];
    state.night.bites = [];
    state.night.sorceressInspectId = null;
    state.night.sorceressResult = null;
    state.night.seerInspectId = null;
    state.night.seerResult = null;
    state.night.apprenticeInspectId = null;
    state.night.apprenticeResult = null;
    state.night.piSelectedIds = [];
    state.night.piResult = null;
    state.night.piChecked = false;
    state.night.piSecondUse = false;
    state.night.cupidSelectedIds = [];
    state.night.cupidConfirmed = false;
    state.night.spellcasterTargetId = null;
    state.night.priestProtectId = null;
    state.night.priestUsed = false;
    state.night.bodyguardId = null;
    state.night.witchSaved = false;
    state.night.witchSaveId = null;
    state.night.witchKillId = null;
    state.night.hunterMarkId = null;
    state.night.hunterDied = false;
    if (!keepPotions){
      state.night.witchSaveUsed = false;
      state.night.witchKillUsed = false;
    }
  }

  // ----- UI Builders -----
  function renderPlayersTextarea(){ $("playersTextarea").value = state.players.map(p => p.name).join("\n"); }

  function applyPlayersFromTextarea(){
    const names = linesFromTextarea();
    const prev = state.players;
    state.playerCount = names.length;
    state.players = names.map((name, idx) => ({
      id: idx+1,
      name,
      alive: prev[idx]?.alive ?? true,
      role: prev[idx]?.role ? normalizeRole(prev[idx].role) : null,
      baseRole: prev[idx]?.baseRole ?? (prev[idx]?.role === ROLE.DOPPELGANGER ? ROLE.DOPPELGANGER : null)
    }));

    while (roleTotal() > state.playerCount){
      if (state.roles[ROLE.VILLAGER] > 0) state.roles[ROLE.VILLAGER]--;
      else break;
    }
    saveState();
  }

  function renderRoleTables(){
    const evil = [ROLE.WEREWOLF, ROLE.SORCERESS, ROLE.WOLFCUB, ROLE.DIRE_WOLF, ROLE.FRUIT_WOLF];
    const good = [ROLE.SEER, ROLE.APPRENTICE_SEER, ROLE.MASON, ROLE.BODYGUARD, ROLE.HUNTER, ROLE.WITCH, ROLE.DISEASED, ROLE.TOUGH_GUY, ROLE.PI, ROLE.MAYOR, ROLE.CUPID, ROLE.DOPPELGANGER, ROLE.SPELLCASTER, ROLE.PRIEST, ROLE.IDIOT, ROLE.PACIFIST, ROLE.TROUBLEMAKER, ROLE.VILLAGER];
    const other = [ROLE.SOBER];

    function cssId(s){ return s.replace(/\s+/g,"_").toLowerCase(); }
    function row(role){
      const tr = document.createElement("tr");
      tr.dataset.role = role;
      if ((state.roles[role] ?? 0) === 0) tr.classList.add("disabledRow");
      const evilClass = roleMeta[role]?.side === SIDE.EVIL ? " bad" : "";
      const otherClass = roleMeta[role]?.side === SIDE.OTHER ? " other" : "";
      tr.innerHTML = `
        <td style="width:55%">
          <div class="${evilClass}${otherClass}"><b>${role}</b></div>
          <div class="mini${evilClass}${otherClass}">${roleMeta[role].note}</div>
        </td>
        <td style="width:45%;text-align:right">
          <div class="qty">
            <button class="secondary" data-role="${role}" data-delta="-1">−</button>
            <b id="qty_${cssId(role)}">${state.roles[role]}</b>
            <button data-role="${role}" data-delta="1">+</button>
          </div>
        </td>
      `;
      return tr;
    }

    function updateRoleSideCounts(){
      const evilCount = evil.reduce((sum, r) => sum + (state.roles[r] ?? 0), 0);
      const goodCount = good.reduce((sum, r) => sum + (state.roles[r] ?? 0), 0);
      const otherCount = other.reduce((sum, r) => sum + (state.roles[r] ?? 0), 0);
      const e = $("evilCount"); if (e) e.textContent = evilCount;
      const g = $("goodCount"); if (g) g.textContent = goodCount;
      const o = $("otherCount"); if (o) o.textContent = otherCount;
    }

    const tE = $("roleTableEvil"); tE.innerHTML = ""; evil.forEach(r => tE.appendChild(row(r)));
    const tG = $("roleTableGood"); tG.innerHTML = ""; good.forEach(r => tG.appendChild(row(r)));
    const tO = $("roleTableOther"); tO.innerHTML = ""; other.forEach(r => tO.appendChild(row(r)));
    updateRoleSideCounts();

    for (const btn of document.querySelectorAll("table .qty button")){
      btn.onclick = async () => {
        const role = btn.dataset.role;
        const delta = parseInt(btn.dataset.delta,10);
        const next = state.roles[role] + delta;
        if (next < 0) return;

        const totalNext = roleTotal() + delta;
        if (delta > 0 && totalNext > state.playerCount){
          await alertModal(`Role total exceeds player count. (${roleTotal()} / ${state.playerCount})`);
          return;
        }

        state.roles[role] = next;

        for (const r of Object.keys(state.roles)){
          const el = document.getElementById("qty_"+cssId(r));
          if (el) el.textContent = state.roles[r];
        }
        const rowEl = document.querySelector(`tr[data-role="${role}"]`);
        if (rowEl){
          if (state.roles[role] === 0) rowEl.classList.add("disabledRow");
          else rowEl.classList.remove("disabledRow");
        }
        updateRoleSideCounts();
        updateQuickStatus();
        saveState();
      };
    }
  }

  function renderPlayersGrid(elId, opts = {}){
    const el = $(elId);
    el.innerHTML = "";
    state.players.forEach(p => {
      const btn = document.createElement("button");
      btn.className = "playerBtn" + (p.alive ? "" : " dead");
      if (isEvilRole(p.role)) btn.classList.add("evil");
      btn.innerHTML = `
        <span class="name"><b>${p.id}.</b> ${escapeHtml(p.name)}</span>
        <span class="mini">${escapeHtml(getDisplayRole(p))}</span>
      `;
      btn.disabled = opts.disableDeadClick ? !p.alive : false;
      btn.onclick = () => opts.onClick && opts.onClick(p);
      el.appendChild(btn);
    });
  }

  // ----- Assign Roles Screen -----
  function rolePoolFromConfig(){
    const pool = [];
    for (const [role, qty] of Object.entries(state.roles)){
      for (let i=0;i<qty;i++) pool.push(role);
    }
    // fill remaining with Villager
    while (pool.length < state.playerCount) pool.push(ROLE.VILLAGER);
    return pool;
  }

  function countAssigned(){
    const counts = {};
    for (const r of Object.keys(state.roles)) counts[r] = 0;
    counts[ROLE.VILLAGER] ??= 0;
    state.players.forEach(p => {
      const r = p.role || ROLE.VILLAGER;
      counts[r] = (counts[r]||0) + 1;
    });
    return counts;
  }

  function remainingCounts(){
    const assigned = countAssigned();
    const remaining = {};
    for (const [role, qty] of Object.entries(state.roles)){
      remaining[role] = qty - (assigned[role] || 0);
    }
    // Villager is special: it's the filler, no cap needed here (we allow remainder)
    remaining[ROLE.VILLAGER] = state.playerCount - Object.values(assigned).reduce((a,b)=>a+b,0);
    return remaining;
  }

  function renderAssignRoles(){
    const list = $("assignRolesList");
    list.innerHTML = "";

    const allowedRoles = Object.keys(state.roles).filter(r => state.roles[r] > 0);
    // allow empty selection; include Villager only if configured
    if (state.roles[ROLE.VILLAGER] > 0 && !allowedRoles.includes(ROLE.VILLAGER)) allowedRoles.push(ROLE.VILLAGER);

    let changed = false;
    state.players.forEach(p => {
      if (p.role && !roleMeta[p.role]){
        p.role = ROLE.VILLAGER;
        if (p.baseRole === ROLE.DOPPELGANGER) p.baseRole = null;
        changed = true;
      }
      const row = document.createElement("div");
      row.className = "roleRow";
      row.innerHTML = `
        <div>
          <b>${p.id}. ${escapeHtml(p.name)}</b>
        </div>
        <div>
          <select data-pid="${p.id}">
            <option value="" ${!p.role ? "selected":""}>—</option>
            ${allowedRoles.map(r => `<option value="${escapeHtml(r)}" ${p.role===r ? "selected":""}>${escapeHtml(r)}</option>`).join("")}
          </select>
        </div>
      `;
      list.appendChild(row);
    });

    for (const sel of list.querySelectorAll("select")){
      sel.onchange = () => {
        const pid = parseInt(sel.dataset.pid,10);
        const p = state.players.find(x => x.id === pid);
        if (!p) return;

        const nextRole = sel.value;

        p.role = nextRole || null;
        p.baseRole = (p.role === ROLE.DOPPELGANGER) ? ROLE.DOPPELGANGER : null;
        renderAssignSidebar();
        saveState();
      };
    }

    renderAssignSidebar();
    if (changed) saveState();
  }

  function renderAssignSidebar(){
    const rem = remainingCounts();
    const box = $("remainingCounts");
    box.innerHTML = "";

    const items = [
      ROLE.WEREWOLF, ROLE.SORCERESS, ROLE.WOLFCUB, ROLE.FRUIT_WOLF, ROLE.SEER, ROLE.APPRENTICE_SEER, ROLE.MASON, ROLE.BODYGUARD, ROLE.HUNTER, ROLE.WITCH, ROLE.DISEASED, ROLE.TOUGH_GUY, ROLE.PI, ROLE.MAYOR, ROLE.CUPID, ROLE.SPELLCASTER, ROLE.PRIEST, ROLE.DOPPELGANGER, ROLE.SOBER, ROLE.IDIOT, ROLE.PACIFIST, ROLE.TROUBLEMAKER, ROLE.VILLAGER
    ].filter(r => (r===ROLE.VILLAGER) || (state.roles[r] != null));

    items.forEach(r => {
      const el = document.createElement("div");
      el.className = "kpi";
      const cap = (r === ROLE.VILLAGER) ? "filler" : String(state.roles[r]);
      const val = (rem[r] ?? 0);
      const ok = (r === ROLE.VILLAGER) ? "" : (val < 0 ? "bad" : val === 0 ? "ok" : "warn");
      if (val === 0) return;
      el.innerHTML = `<div class="mini">${escapeHtml(r)} (max: ${cap})</div><b class="${ok}">${val}</b>`;
      box.appendChild(el);
    });

    const hasRemaining = items.some(r => (rem[r] ?? 0) !== 0);
    const block = $("remainingBlock");
    if (block) block.style.display = hasRemaining ? "" : "none";

    // validation: all non-villager roles must be fully assigned (remaining 0)
    const bad = Object.keys(state.roles)
      .filter(r => r !== ROLE.VILLAGER)
      .some(r => (rem[r] ?? 0) !== 0);

    $("assignValidation").innerHTML = bad
      ? `<span class="warn">Configured roles are not fully assigned. Please review remaining roles and assign them all.</span>`
      : `<span class="ok">Ready: all configured roles assigned.</span>`;

    $("startGameBtn").disabled = bad;
  }

  function autoFillRolesRandom(){
    const pool = rolePoolFromConfig();
    // shuffle
    for (let i=pool.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [pool[i], pool[j]] = [pool[j], pool[i]];
    }
    state.players.forEach((p, idx) => {
      p.role = pool[idx] || ROLE.VILLAGER;
      p.baseRole = (p.role === ROLE.DOPPELGANGER) ? ROLE.DOPPELGANGER : null;
    });
    renderAssignRoles();
    saveState();
  }

  function clearRoles(){
    state.players.forEach(p => { p.role = null; p.baseRole = null; });
    renderAssignRoles();
    saveState();
  }

  function getNightPrompt(step){
    const hasBites = (state.night.bites && state.night.bites.length > 0);
    const prompts = {
      cupid: "Cupid, wake up. Cupid selects 2 players to become a couple. You may choose not to use this ability.\n(After touching 2 players) The touched couple, wake up. These are your partners roles (show them the role popup, or they may silently reveal their cards).",
      werewolf: (() => {
        const canBite = canWolvesBite();
        const canDoubleBite = state.day.wolfCubDiedLastDay && canBite;
        const biteLine = canDoubleBite
          ? "Wolves select players to bite (secretly tell them to bite 2 players tonight)."
          : "Wolves select players to bite.";
        if (state.night.number !== 1) return `Wolves, wake up. ${biteLine}`;
        const evilRoles = Object.keys(roleMeta)
          .filter(r => roleMeta[r]?.side === SIDE.EVIL && r !== ROLE.WEREWOLF);
        const identifyLines = evilRoles.map(role => {
          const names = state.players.filter(p => p.role === role).map(p => p.name).filter(Boolean);
          if (!names.length) return "";
          return `Who is ${role}? (${names.join(", ")} should raise hand)`;
        }).filter(Boolean);
        const lines = ["Wolves, wake up."].concat(identifyLines).concat([biteLine]);
        return lines.join("\n");
      })(),
      sorceress: "Sorceress, wake up. Sorceress selects players to check if they are Seer.",
      troublemaker: (state.day.troublemakerLastUseNight != null && state.day.troublemakerLastUseNight < state.night.number)
        ? "Troublemaker, wake up. Do you want to activate 2 lynches for the next day? (no uses remaining)"
        : "Troublemaker, wake up. Do you want to activate 2 lynches for the next day?",
      dire_wolf: "Dire Wolf, wake up. Dire Wolf chooses a player. If that player dies, Dire Wolf dies with them.",
      doppelganger: (state.night.number > 1)
        ? ((state.day.doppelgangerPendingRole || state.day.doppelgangerRole)
            ? `Doppelganger, wake up. This is the eliminated person role (show them their new ${(state.day.doppelgangerPendingRole || state.day.doppelgangerRole)} role)`
            : `Doppelganger, wake up. This is the eliminated person role (do nothing)`)
        : "Doppelganger, wake up. Doppelganger choose a player to copy. After that player is eliminated, you become that role.",
      mason: (() => {
        const names = state.players.filter(p => p.role === ROLE.MASON).map(p => p.name).filter(Boolean).join(", ");
        const suffix = names ? ` (${names})` : "";
        return `Mason, wake up. Mason identifies all other Masons${suffix}`;
      })(),
      seer: "Seer, wake up. Seer selects players to reveal.",
      couple: "Couple, wake up. You may briefly discuss.",
      apprentice_seer: (() => {
        const seerAlive = isRoleAlive(ROLE.SEER);
        if (seerAlive){
          return "Apprentice Seer, wake up. Apprentice Seer selects players to reveal (secretly tell them that the Seer has not died yet).";
        }
        const seer = state.players.find(p => p.role === ROLE.SEER);
        const seerDiedLastNight = !!(seer && state.day.lastNightDeaths && state.day.lastNightDeaths.includes(seer.id));
        if (seerDiedLastNight){
          const appr = state.players.find(p => p.role === ROLE.APPRENTICE_SEER);
          const apprName = appr ? appr.name : "Apprentice Seer";
          const seerName = seer ? seer.name : "Seer";
          return `Apprentice Seer, wake up (secretly point at ${apprName} because ${seerName} died last night). Apprentice Seer selects players to reveal.`;
        }
        return "Apprentice Seer, wake up. Apprentice Seer selects players to reveal.";
      })(),
      pi: (state.day.piLastUseNight != null && state.day.piLastUseNight < state.night.number)
        ? "PI, wake up. PI selects players to reveal. (no uses remaining)"
        : "PI, wake up. PI selects players to reveal.",
      spellcaster: "Spellcaster, wake up. Spellcaster selects players to mute them the next day.",
      priest: (state.day.priestLastUseNight != null && state.day.priestLastUseNight < state.night.number)
        ? "Priest, wake up. Priest selects players to protect them from wolf bites at night. (no uses remaining)"
        : "Priest, wake up. Priest selects players to protect them from wolf bites at night.",
      bodyguard: "Bodyguard, wake up. Bodyguard selects players to protect tonight.",
      witch: (() => {
        const effectiveBites = (state.night.bites || []).filter(id => id !== state.night.bodyguardId);
        const bittenNames = effectiveBites.length ? effectiveBites.map(labelPlayer).join(", ") : "";
        const saveUsedBefore = (state.day.witchSaveLastUseNight != null && state.day.witchSaveLastUseNight < state.night.number);
        const healNote = saveUsedBefore
          ? `(no uses remaining)`
          : (effectiveBites.length
              ? `(point at ${bittenNames})`
              : `(secretly tell them no players are dying)`);
        const killNote = (state.day.witchKillLastUseNight != null && state.day.witchKillLastUseNight < state.night.number) ? " (no uses remaining)" : "";
        return `Witch, wake up.\nTonight, these players are about to die. ${healNote} Do you want to heal them?\nWhich players do you want to kill?${killNote}`;
      })(),
      hunter: "Hunter, wake up. Hunter selects players to mark as targets.",
    };
    return prompts[step] || "";
  }

  function formatPrompt(text){
    if (!text) return "";
    const esc = (s) => String(s).replace(/[&<>]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]));
    let safe = esc(text);
    safe = safe.replace(/\(([^)]+)\)/g, '<span class="aside">($1)</span>');
    return safe.replace(/\n/g, "<br>");
  }

  // ----- Night Panels -----
  function renderNight(){
    $("nightNumber").textContent = state.night.number;
    $("livingCount").textContent = livingPlayers().length;

    state.night.steps = buildNightSteps();
    state.night.stepIndex = clamp(state.night.stepIndex, 0, Math.max(0, state.night.steps.length-1));
    const step = state.night.steps[state.night.stepIndex] || "—";
    let stepLabel = String(step).replace(/_/g," ").toUpperCase();
    if (stepLabel && stepLabel !== "?"){
      if (step === "couple"){
        const ids = state.day.coupleIds || [];
        const [aId, bId] = ids;
        const a = state.players.find(x => x.id === aId);
        const b = state.players.find(x => x.id === bId);
        if (!a || !b || !a.alive || !b.alive) stepLabel += " (DEAD)";
      } else {
        const roleMap = {
          doppelganger: ROLE.DOPPELGANGER,
          werewolf: ROLE.WEREWOLF,
          sorceress: ROLE.SORCERESS,
          troublemaker: ROLE.TROUBLEMAKER,
          mason: ROLE.MASON,
          cupid: ROLE.CUPID,
          seer: ROLE.SEER,
          apprentice_seer: ROLE.APPRENTICE_SEER,
          pi: ROLE.PI,
          spellcaster: ROLE.SPELLCASTER,
          priest: ROLE.PRIEST,
          bodyguard: ROLE.BODYGUARD,
          witch: ROLE.WITCH,
          hunter: ROLE.HUNTER,
        };
        const role = roleMap[step];
        if (role && !isRoleEffectivelyAlive(role)) stepLabel += " (DEAD)";
      }
    }
    const nightTitle = $("nightTitle");
    if (nightTitle) nightTitle.textContent = stepLabel;
    const nightPrompt = $("nightPrompt");
    if (nightPrompt){
      nightPrompt.innerHTML = formatPrompt(getNightPrompt(step));
    }

    $("nightPrevBtn").disabled = state.night.stepIndex === 0;
    const atLastStep = state.night.stepIndex >= state.night.steps.length-1;
    $("nightNextBtn").disabled = false;
    $("nightNextBtn").textContent = atLastStep ? "End this night" : "Next role";
    $("nightNextBtn").classList.toggle("good", atLastStep);

    const panel = $("nightPanel");
    panel.innerHTML = "";

    if (step === "dire_wolf") renderDireWolfPanel(panel);
    else if (step === "doppelganger") renderDoppelgangerPanel(panel);
    else if (step === "werewolf") renderWerewolfPanel(panel);
    else if (step === "sorceress") renderSorceressPanel(panel);
    else if (step === "troublemaker") renderTroublemakerPanel(panel);
    else if (step === "mason") renderMasonPanel(panel);
    else if (step === "cupid") renderCupidPanel(panel);
    else if (step === "seer") renderSeerPanel(panel);
    else if (step === "apprentice_seer") renderApprenticeSeerPanel(panel);
    else if (step === "couple") renderCouplePanel(panel);
    else if (step === "pi") renderPIPanel(panel);
    else if (step === "spellcaster") renderSpellcasterPanel(panel);
    else if (step === "priest") renderPriestPanel(panel);
    else if (step === "bodyguard") renderBodyguardPanel(panel);
    else if (step === "witch") renderWitchPanel(panel);
    else if (step === "hunter") renderHunterPanel(panel);
    else panel.innerHTML = `<div class="mini muted">No night steps (no roles configured).</div>`;
    saveState();
  }

  function renderWerewolfPanel(panel){
    const wolvesAlive = aliveWolves();
    const canBite = canWolvesBite();
    const canTwoBite = state.day.wolfCubDiedLastDay && canBite;
    const biteCap = canBite ? (canTwoBite ? 2 : 1) : 0;
    if (!canBite && state.night.bites.length) state.night.bites = [];

    panel.innerHTML = `
      <div class="${wolvesAlive ? "" : "disabledSection"}">
        ${selectionSummary(state.night.bites, biteCap)}
        ${wolvesAlive ? "" : '<div class="mini warn" style="margin-top:6px">All wolves are dead.</div>'}
        <div id="werewolfPick" class="grid" style="margin-top:10px"></div>
      </div>
    `;

    const pick = $("werewolfPick");
    state.players.forEach(p => {
      const b = document.createElement("button");
      b.className = "playerBtn" + (p.alive ? "" : " dead");
      if (isEvilRole(p.role)) b.classList.add("evil");
      if (p.role === ROLE.WEREWOLF || p.role === ROLE.WOLFCUB || p.role === ROLE.SORCERESS || p.role === ROLE.DIRE_WOLF || p.role === ROLE.FRUIT_WOLF) b.classList.add("roleHighlight");
      b.disabled = !p.alive || !wolvesAlive || !canBite;
      const chosen = state.night.bites.includes(p.id);
      b.style.outline = chosen ? "2px solid rgba(255,209,102,.8)" : "";
      const roleLabel = escapeHtml(getDisplayRole(p));
      b.innerHTML = `<span class="name"><b>${p.id}.</b> ${escapeHtml(p.name)}</span><span class="mini">${roleLabel}${chosen ? " • chosen" : ""}</span>`;
      b.onclick = () => {
        if (!p.alive || !wolvesAlive) return;
        const idx = state.night.bites.indexOf(p.id);
        if (idx >= 0) state.night.bites.splice(idx,1);
        else {
          if (state.night.bites.length >= biteCap) state.night.bites.shift();
          state.night.bites.push(p.id);
        }
        renderNight();
      };
      pick.appendChild(b);
    });
  }

  function renderSeerPanel(panel){
    const seerAlive = isRoleAlive(ROLE.SEER);
    panel.innerHTML = `
      <div class="${seerAlive ? "" : "disabledSection"}">
        <div class="mini">Result: <b>${state.night.seerResult || "—"}</b></div>
        <div class="hr"></div>
        ${selectionSummary(state.night.seerInspectId ? [state.night.seerInspectId] : [], 1)}
        <div id="seerPick" class="grid"></div>
      </div>
    `;
    const pick = $("seerPick");
    state.players.forEach(p => {
      const b = document.createElement("button");
      b.className = "playerBtn" + (p.alive ? "" : " dead");
      if (isEvilRole(p.role)) b.classList.add("evil");
      if (p.role === ROLE.SEER) b.classList.add("roleHighlight");
      b.disabled = !p.alive || !seerAlive;
      const chosen = state.night.seerInspectId === p.id;
      b.style.outline = chosen ? "2px solid rgba(98,255,167,.8)" : "";
      const roleLabel = escapeHtml(getDisplayRole(p));
      b.innerHTML = `<span class="name"><b>${p.id}.</b> ${escapeHtml(p.name)}</span><span class="mini">${roleLabel}${chosen ? " • inspect" : ""}</span>`;
      b.onclick = () => {
        if (!seerAlive) return;
        state.night.seerInspectId = p.id;
        const res = isEvilRole(p.role) ? "Not Villager (Evil)" : "Villager side (Good)";
        state.night.seerResult = res;
        renderNight();
      };
      pick.appendChild(b);
    });
  }

  function renderBodyguardPanel(panel){
    const bgAlive = isRoleAlive(ROLE.BODYGUARD);
    const lastBgId = state.day.lastBodyguardId;
    panel.innerHTML = `
      <div class="${bgAlive ? "" : "disabledSection"}">
        ${selectionSummary(state.night.bodyguardId ? [state.night.bodyguardId] : [], 1)}
        <div id="bgPick" class="grid"></div>
        ${lastBgId ? `<div class="mini warn" style="margin-top:6px">Cannot protect ${labelPlayer(lastBgId)} two nights in a row.</div>` : ""}
      </div>
    `;
    const pick = $("bgPick");
    state.players.forEach(p => {
      const b = document.createElement("button");
      b.className = "playerBtn" + (p.alive ? "" : " dead");
      if (isEvilRole(p.role)) b.classList.add("evil");
      if (p.role === ROLE.BODYGUARD) b.classList.add("roleHighlight");
      const blockedRepeat = (p.id === lastBgId);
      b.disabled = !p.alive || !bgAlive;
      const chosen = state.night.bodyguardId === p.id;
      b.style.outline = chosen ? "2px solid rgba(98,255,167,.8)" : "";
      const roleLabel = escapeHtml(getDisplayRole(p));
      b.innerHTML = `<span class="name"><b>${p.id}.</b> ${escapeHtml(p.name)}</span><span class="mini">${roleLabel}${chosen ? " • protected" : ""}</span>`;
      b.onclick = async () => {
        if (!bgAlive) return;
        if (blockedRepeat){
          const ok = await confirmModal(`Bodyguard protected ${labelPlayer(p.id)} last night. Protect again?`);
          if (!ok) return;
        }
        state.night.bodyguardId = p.id;
        renderNight();
      };
      pick.appendChild(b);
    });

  }

  function renderMasonPanel(panel){
    const masons = state.players.filter(p => p.role === ROLE.MASON);
    const canAct = state.night.number === 1;
    panel.innerHTML = `
      <div class="${canAct ? "" : "disabledSection"}">
        <div class="mini">Masons (first night only):</div>
        <div class="hr"></div>
        <div id="masonPick" class="grid"></div>
        ${canAct ? "" : '<div class="mini warn" style="margin-top:6px">Masons do not wake after the first night.</div>'}
      </div>
    `;
    const pick = $("masonPick");
    state.players.forEach(p => {
      const b = document.createElement("button");
      b.className = "playerBtn" + (p.alive ? "" : " dead");
      if (isEvilRole(p.role)) b.classList.add("evil");
      if (p.role === ROLE.MASON) b.classList.add("roleHighlight");
      b.disabled = true;
      const roleLabel = escapeHtml(getDisplayRole(p));
      b.innerHTML = `<span class="name"><b>${p.id}.</b> ${escapeHtml(p.name)}</span><span class="mini">${roleLabel}</span>`;
      pick.appendChild(b);
    });
  }

  function renderDoppelgangerPanel(panel){
    const alive = isRoleAlive(ROLE.DOPPELGANGER);
    const targetId = state.day.doppelgangerTargetId;
    const canChoose = alive && state.night.number === 1;
    const targetPlayer = state.players.find(p => p.id === state.day.doppelgangerTargetId);
    const targetAlive = !!(targetPlayer && targetPlayer.alive);
    const infoRole = alive ? (targetPlayer ? getDisplayRole(targetPlayer) : (state.day.doppelgangerRole || state.day.doppelgangerPendingRole)) : null;
    const statusLabel = targetPlayer ? (targetAlive ? "ALIVE" : "DEAD") : null;
    panel.innerHTML = `
      <div>
        <div class="mini">Chosen role: <b>${infoRole ? escapeHtml(infoRole) : "—"}</b>${statusLabel ? ` <span class="mini">are ${statusLabel}</span>` : ""}</div>
        ${infoRole ? `<button id="doppelShowRoleBtn" class="good menuWide" style="margin-top:8px" ${targetAlive ? "disabled" : ""}>Show role to player</button>` : ""}
        <div class="hr"></div>
        ${(state.night.number === 1) ? selectionSummary(targetId ? [targetId] : [], 1) : ""}
        ${(state.night.number === 1) ? '<div id="doppelPick" class="grid"></div>' : ""}
      </div>
    `;
    const showBtn = $("doppelShowRoleBtn");
    if (showBtn){
      showBtn.onclick = async () => {
        if (!infoRole) return;
        if (targetAlive) return;
        await showModal({title:"", message:`You are now ${infoRole}`, confirmText:"OK", bigMessage:true});
      };
    }
    const pick = $("doppelPick");
    if (pick && canChoose){
      state.players.forEach(p => {
        const b = document.createElement("button");
        b.className = "playerBtn" + (p.alive ? "" : " dead");
        if (isEvilRole(p.role)) b.classList.add("evil");
        if (p.role === ROLE.DOPPELGANGER || p.baseRole === ROLE.DOPPELGANGER) b.classList.add("roleHighlight");
        b.disabled = !canChoose;
        const chosen = targetId === p.id;
        b.style.outline = chosen ? "2px solid rgba(98,255,167,.8)" : "";
        const roleLabel = escapeHtml(getDisplayRole(p));
        b.innerHTML = `<span class="name"><b>${p.id}.</b> ${escapeHtml(p.name)}</span><span class="mini">${roleLabel}${chosen ? " • chosen" : ""}</span>`;
        b.onclick = () => {
          if (!canChoose) return;
          if (targetId === p.id) state.day.doppelgangerTargetId = null;
          else state.day.doppelgangerTargetId = p.id;
          renderNight();
        };
        pick.appendChild(b);
      });
    }
  }

  function renderDireWolfPanel(panel){
    const alive = isRoleAlive(ROLE.DIRE_WOLF);
    const targetId = state.day.direWolfTargetId;
    const canChoose = alive && state.night.number === 1;
    panel.innerHTML = `
      <div class="${alive ? "" : "disabledSection"}">
        ${selectionSummary(targetId ? [targetId] : [], 1)}
        <div id="direWolfPick" class="grid"></div>
      </div>
    `;
    const pick = $("direWolfPick");
    if (pick && canChoose){
      state.players.forEach(p => {
        const b = document.createElement("button");
        b.className = "playerBtn" + (p.alive ? "" : " dead");
        if (isEvilRole(p.role)) b.classList.add("evil");
        if (p.role === ROLE.DIRE_WOLF) b.classList.add("roleHighlight");
        b.disabled = !p.alive || !canChoose;
        const chosen = targetId === p.id;
        b.style.outline = chosen ? "2px solid rgba(255,209,102,.8)" : "";
        const roleLabel = escapeHtml(getDisplayRole(p));
        b.innerHTML = `<span class="name"><b>${p.id}.</b> ${escapeHtml(p.name)}</span><span class="mini">${roleLabel}${chosen ? " • chosen" : ""}</span>`;
        b.onclick = () => {
          if (!canChoose) return;
          if (targetId === p.id) state.day.direWolfTargetId = null;
          else state.day.direWolfTargetId = p.id;
          renderNight();
        };
        pick.appendChild(b);
      });
    }
  }

  function renderCupidPanel(panel){
    const cupidAlive = isRoleAlive(ROLE.CUPID);
    panel.innerHTML = `
      <div class="${cupidAlive ? "" : "disabledSection"}">
        <div class="mini">Select 2 players to become a couple.</div>
        <div class="hr"></div>
        ${selectionSummary(state.night.cupidSelectedIds, 2)}
        <div id="cupidPick" class="grid"></div>
        ${!cupidAlive ? '<div class="mini warn" style="margin-top:6px">Cupid is dead.</div>' : ''}
      </div>
    `;
    const pick = $("cupidPick");
    state.players.forEach(p => {
      const b = document.createElement("button");
      b.className = "playerBtn" + (p.alive ? "" : " dead");
      if (isEvilRole(p.role)) b.classList.add("evil");
      if (p.role === ROLE.CUPID) b.classList.add("roleHighlight");
      b.disabled = !p.alive || !cupidAlive;
      const chosen = state.night.cupidSelectedIds.includes(p.id);
      b.style.outline = chosen ? "2px solid rgba(255,209,102,.8)" : "";
      const roleLabel = escapeHtml(getDisplayRole(p));
      b.innerHTML = `<span class="name"><b>${p.id}.</b> ${escapeHtml(p.name)}</span><span class="mini">${roleLabel}${chosen ? " • chosen" : ""}</span>`;
      b.onclick = async () => {
        if (!cupidAlive) return;
        const idx = state.night.cupidSelectedIds.indexOf(p.id);
        if (idx >= 0) state.night.cupidSelectedIds.splice(idx,1);
        else {
          if (state.night.cupidSelectedIds.length >= 2) state.night.cupidSelectedIds.shift();
          state.night.cupidSelectedIds.push(p.id);
        }
        if (state.night.cupidSelectedIds.length === 2){
          state.day.coupleIds = [...state.night.cupidSelectedIds];
          state.night.cupidConfirmed = true;
          const [aId, bId] = state.day.coupleIds;
          const a = state.players.find(x => x.id === aId);
          const b = state.players.find(x => x.id === bId);
          const msg = `${a?.name || "A"} is ${getDisplayRole(a)}.\n${b?.name || "B"} is ${getDisplayRole(b)}.`;
          await showModal({title:"COUPLE", message: msg, confirmText:"OK", bigMessage:true});
        }
        renderNight();
      };
      pick.appendChild(b);
    });
  }

  function renderCouplePanel(panel){
    const ids = state.day.coupleIds || [];
    const [aId, bId] = ids;
    const a = state.players.find(x => x.id === aId);
    const b = state.players.find(x => x.id === bId);
    panel.innerHTML = `
      <div>
        <div class="mini">Couple: <b>${a ? labelPlayer(aId) : "—"}</b> & <b>${b ? labelPlayer(bId) : "—"}</b></div>
        <div class="hr"></div>
        <div class="mini">They wake up and may discuss briefly.</div>
      </div>
    `;
  }

  function renderSorceressPanel(panel){
    const sorcAlive = isRoleAlive(ROLE.SORCERESS);
    panel.innerHTML = `
      <div class="${sorcAlive ? "" : "disabledSection"}">
        <div class="mini">Result: <b>${state.night.sorceressResult || "—"}</b></div>
        <div class="hr"></div>
        ${selectionSummary(state.night.sorceressInspectId ? [state.night.sorceressInspectId] : [], 1)}
        <div id="sorceressPick" class="grid"></div>
      </div>
    `;
    const pick = $("sorceressPick");
    state.players.forEach(p => {
      const b = document.createElement("button");
      b.className = "playerBtn" + (p.alive ? "" : " dead");
      if (isEvilRole(p.role)) b.classList.add("evil");
      if (p.role === ROLE.SORCERESS) b.classList.add("roleHighlight");
      b.disabled = !p.alive || !sorcAlive;
      const chosen = state.night.sorceressInspectId === p.id;
      b.style.outline = chosen ? "2px solid rgba(255,209,102,.8)" : "";
      const roleLabel = escapeHtml(getDisplayRole(p));
      b.innerHTML = `<span class="name"><b>${p.id}.</b> ${escapeHtml(p.name)}</span><span class="mini">${roleLabel}${chosen ? " • inspect" : ""}</span>`;
      b.onclick = () => {
        if (!sorcAlive) return;
        state.night.sorceressInspectId = p.id;
        const res = (p.role === ROLE.SEER) ? "Seer" : "Not Seer";
        state.night.sorceressResult = res;
        renderNight();
      };
      pick.appendChild(b);
    });
  }

  function renderTroublemakerPanel(panel){
    const tmAlive = isRoleAlive(ROLE.TROUBLEMAKER);
    const tmUsed = state.day.troublemakerUsed;
    const pending = state.day.troublemakerPendingNextDay;
    const showUsedWarn = (state.day.troublemakerLastUseNight != null && state.day.troublemakerLastUseNight < state.night.number);
    panel.innerHTML = `
      <div class="${tmAlive && !tmUsed ? "" : "disabledSection"}">
        <div class="mini">Once per game: allow 2 lynches for the next day.</div>
        <div class="hr"></div>
        <button id="troublemakerToggleBtn" class="good menuWide" ${(!tmAlive || pending) ? "disabled" : ""}>
          Enable for next day
        </button>
        ${showUsedWarn ? getOutOfUsageWarning() : ''}
      </div>
    `;
    const btn = $("troublemakerToggleBtn");
    if (btn){
      btn.onclick = async () => {
        if (!tmAlive) return;
        if (tmUsed){
          const ok = await confirmModal("Troublemaker already used in a previous night. Use again?");
          if (!ok) return;
        }
        state.day.troublemakerPendingNextDay = true;
        state.day.troublemakerUsed = true;
        state.day.troublemakerLastUseNight = state.night.number;
        renderNight();
      };
    }
  }

  function renderApprenticeSeerPanel(panel){
    const apprenticeAlive = isRoleAlive(ROLE.APPRENTICE_SEER);
    const seerAlive = isRoleAlive(ROLE.SEER);
    const canAct = apprenticeAlive && !seerAlive;
    panel.innerHTML = `
      <div class="${canAct ? "" : "disabledSection"}">
        <div class="mini">Result: <b>${state.night.apprenticeResult || "—"}</b></div>
        <div class="hr"></div>
        ${selectionSummary(state.night.apprenticeInspectId ? [state.night.apprenticeInspectId] : [], 1)}
        <div id="apprenticePick" class="grid"></div>
        ${seerAlive ? '<div class="mini warn" style="margin-top:6px">Seer is still alive. Apprentice Seer cannot act yet.</div>' : ''}
        ${!apprenticeAlive ? '<div class="mini warn" style="margin-top:6px">Apprentice Seer is dead.</div>' : ''}
      </div>
    `;
    const pick = $("apprenticePick");
    state.players.forEach(p => {
      const b = document.createElement("button");
      b.className = "playerBtn" + (p.alive ? "" : " dead");
      if (isEvilRole(p.role)) b.classList.add("evil");
      if (p.role === ROLE.APPRENTICE_SEER) b.classList.add("roleHighlight");
      b.disabled = !p.alive || !canAct;
      const chosen = state.night.apprenticeInspectId === p.id;
      b.style.outline = chosen ? "2px solid rgba(98,255,167,.8)" : "";
      const roleLabel = escapeHtml(getDisplayRole(p));
      b.innerHTML = `<span class="name"><b>${p.id}.</b> ${escapeHtml(p.name)}</span><span class="mini">${roleLabel}${chosen ? " • inspect" : ""}</span>`;
      b.onclick = () => {
        if (!canAct) return;
        state.night.apprenticeInspectId = p.id;
        const res = isEvilRole(p.role) ? "Not Villager (Evil)" : "Villager side (Good)";
        state.night.apprenticeResult = res;
        renderNight();
      };
      pick.appendChild(b);
    });
  }

  function renderPIPanel(panel){
    const piAlive = isRoleAlive(ROLE.PI);
    const uses = state.day.piUses || 0;
    panel.innerHTML = `
      <div class="${piAlive ? "" : "disabledSection"}">
        ${(state.day.piLastUseNight != null && state.day.piLastUseNight < state.night.number) ? getOutOfUsageWarning("margin-bottom:6px") : ''}
        <div class="mini">Result: <b>${state.night.piResult || "—"}</b></div>
        <div class="hr"></div>
        ${selectionSummary(state.night.piSelectedIds, 3)}
        <div id="piPick" class="grid"></div>
        ${!piAlive ? '<div class="mini warn" style="margin-top:6px">P.I. is dead.</div>' : ''}
      </div>
    `;
    const pick = $("piPick");
    state.players.forEach(p => {
      const b = document.createElement("button");
      b.className = "playerBtn" + (p.alive ? "" : " dead");
      if (isEvilRole(p.role)) b.classList.add("evil");
      if (p.role === ROLE.PI) b.classList.add("roleHighlight");
      b.disabled = !p.alive || !piAlive;
      const chosen = state.night.piSelectedIds.includes(p.id);
      b.style.outline = chosen ? "2px solid rgba(98,255,167,.8)" : "";
      const roleLabel = escapeHtml(getDisplayRole(p));
      b.innerHTML = `<span class="name"><b>${p.id}.</b> ${escapeHtml(p.name)}</span><span class="mini">${roleLabel}${chosen ? " • chosen" : ""}</span>`;
      b.onclick = async () => {
        if (!piAlive) return;
        const idx = state.night.piSelectedIds.indexOf(p.id);
        if (idx >= 0) state.night.piSelectedIds.splice(idx,1);
        else {
          if (state.night.piSelectedIds.length >= 3) state.night.piSelectedIds.shift();
          state.night.piSelectedIds.push(p.id);
        }
        if (state.night.piSelectedIds.length === 3){
          const priorUses = (state.day.piUses || 0);
          const secondUse = priorUses >= 1;
          const lastUseNight = state.day.piLastUseNight;
          if (secondUse && lastUseNight != null && lastUseNight < state.night.number){
            const ok = await confirmModal("P.I. already used in a previous night. Use again?");
            if (!ok) return;
          }
          const anyWerewolf = state.night.piSelectedIds.some(id => {
            const p = state.players.find(x => x.id === id);
            return p && isWolfRole(p.role);
          });
          state.night.piResult = anyWerewolf ? "At least one is a Werewolf" : "No Werewolf among them";
          state.night.piChecked = true;
          state.night.piSecondUse = secondUse;
          state.day.piUses = priorUses + 1;
          state.day.piLastUseNight = state.night.number;
        }
        renderNight();
      };
      pick.appendChild(b);
    });
  }

  function renderSpellcasterPanel(panel){
    const alive = isRoleAlive(ROLE.SPELLCASTER);
    panel.innerHTML = `
      <div class="${alive ? "" : "disabledSection"}">
        ${selectionSummary(state.night.spellcasterTargetId ? [state.night.spellcasterTargetId] : [], 1)}
        <div id="spellcasterPick" class="grid"></div>
        ${!alive ? '<div class="mini warn" style="margin-top:6px">Spellcaster is dead.</div>' : ''}
      </div>
    `;
    const pick = $("spellcasterPick");
    state.players.forEach(p => {
      const b = document.createElement("button");
      b.className = "playerBtn" + (p.alive ? "" : " dead");
      if (isEvilRole(p.role)) b.classList.add("evil");
      if (p.role === ROLE.SPELLCASTER) b.classList.add("roleHighlight");
      b.disabled = !p.alive || !alive;
      const chosen = state.night.spellcasterTargetId === p.id;
      b.style.outline = chosen ? "2px solid rgba(98,255,167,.8)" : "";
      const roleLabel = escapeHtml(getDisplayRole(p));
      b.innerHTML = `<span class="name"><b>${p.id}.</b> ${escapeHtml(p.name)}</span><span class="mini">${roleLabel}${chosen ? " • chosen" : ""}</span>`;
      b.onclick = () => {
        if (!alive) return;
        state.night.spellcasterTargetId = p.id;
        renderNight();
      };
      pick.appendChild(b);
    });
  }

  function renderPriestPanel(panel){
    const alive = isRoleAlive(ROLE.PRIEST);
    const warned = state.day.priestLastUseNight && state.day.priestLastUseNight < state.night.number;
    panel.innerHTML = `
      <div class="${alive ? "" : "disabledSection"}">
        ${(warned && state.night.number > 1) ? getOutOfUsageWarning("margin-bottom:6px") : ''}
        ${selectionSummary(state.night.priestProtectId ? [state.night.priestProtectId] : [], 1)}
        <div id="priestPick" class="grid"></div>
        ${!alive ? '<div class="mini warn" style="margin-top:6px">Priest is dead.</div>' : ''}
      </div>
    `;
    const pick = $("priestPick");
    state.players.forEach(p => {
      const b = document.createElement("button");
      b.className = "playerBtn" + (p.alive ? "" : " dead");
      if (isEvilRole(p.role)) b.classList.add("evil");
      if (p.role === ROLE.PRIEST) b.classList.add("roleHighlight");
      b.disabled = !p.alive || !alive;
      const chosen = state.night.priestProtectId === p.id;
      b.style.outline = chosen ? "2px solid rgba(98,255,167,.8)" : "";
      const roleLabel = escapeHtml(getDisplayRole(p));
      b.innerHTML = `<span class="name"><b>${p.id}.</b> ${escapeHtml(p.name)}</span><span class="mini">${roleLabel}${chosen ? " • protected" : ""}</span>`;
      b.onclick = async () => {
        if (!alive) return;
        if (state.night.priestProtectId === p.id){
          state.night.priestProtectId = null;
          renderNight();
          return;
        }
        if (state.day.priestLastUseNight && state.day.priestLastUseNight < state.night.number){
          const ok = await confirmModal("Priest already used in a previous night. Use again?");
          if (!ok) return;
        }
        state.night.priestProtectId = p.id;
        state.night.priestUsed = true;
        state.day.priestLastUseNight = state.night.number;
        renderNight();
      };
      pick.appendChild(b);
    });
  }

  function renderWitchPanel(panel){
    const witchAlive = isRoleAlive(ROLE.WITCH);
    const lifeAvail = !state.night.witchSaveUsed;
    const deathAvail = !state.night.witchKillUsed;

    let bites = [...state.night.bites];
    if (!canWolvesBite()) bites = [];
    const protectedId = state.night.bodyguardId;
    const bittenEffective = bites.filter(id => id !== protectedId);
    const lifeDisabled = !witchAlive;
    const deathAvailableNow = witchAlive;
    const deathOutOfUse = (!deathAvail && state.day.witchKillLastUseNight != null && state.day.witchKillLastUseNight < state.night.number);
    const deathDisabled = !witchAlive || deathOutOfUse;

    const bittenMsg = bites.length ? `Bitten: ${bites.map(labelPlayer).join(", ")}` : "Bitten: —";
    const protMsg = protectedId ? `Bodyguard protected: ${labelPlayer(protectedId)}` : "Bodyguard protected: —";

    panel.innerHTML = `
      <div class="${(!witchAlive ? "disabledSection" : "")}" style="padding:6px 0">
        <div class="badge">Live potion${(state.day.witchSaveLastUseNight != null && state.day.witchSaveLastUseNight < state.night.number) ? " (used)" : ""}</div>
        <div class="mini" style="margin-top:6px;font-size:13px">${bittenMsg}</div>
        <div class="mini" style="margin-top:6px;font-size:13px">${protMsg}</div>
        ${(!lifeAvail && state.day.witchSaveLastUseNight != null && state.day.witchSaveLastUseNight < state.night.number && !state.night.witchSaveId) ? getOutOfUsageWarning("margin-top:6px") : ''}
        <div id="witchSavePick" class="grid" style="margin-top:10px"></div>
      </div>

      <div class="hr"></div>

      <div class="${(!witchAlive ? "disabledSection" : "")}" style="padding:6px 0">
        <div class="badge">Death potion${(state.day.witchKillLastUseNight != null && state.day.witchKillLastUseNight < state.night.number) ? " (used)" : ""}</div>
        ${(!deathAvail && state.day.witchKillLastUseNight != null && state.day.witchKillLastUseNight < state.night.number && !state.night.witchKillId) ? getOutOfUsageWarning("margin-top:6px") : ''}
        <div style="margin-top:8px">${selectionSummary(state.night.witchKillId ? [state.night.witchKillId] : [], 1)}</div>
        <div id="witchKillPick" class="grid" style="margin-top:8px"></div>
      </div>
    `;

    const savePick = $("witchSavePick");
    savePick.innerHTML = "";
    if (bites.length){
      bites.forEach(id => {
        const p = state.players.find(x => x.id === id);
        if (!p) return;
        const btn = document.createElement("button");
        btn.className = "good menuWide";
        const chosen = state.night.witchSaveId === id;
        btn.style.outline = chosen ? "2px solid rgba(98,255,167,.8)" : "";
        btn.textContent = chosen ? `Undo Save ${labelPlayer(id)}` : `Save ${labelPlayer(id)}`;
        btn.disabled = !witchAlive;
        btn.onclick = async () => {
          if (!witchAlive) return;
          if (state.night.witchSaveId === id){
            state.night.witchSaveId = null;
            state.night.witchSaved = false;
            renderNight();
            return;
          }
          if (!lifeAvail && state.day.witchSaveLastUseNight != null && state.day.witchSaveLastUseNight < state.night.number){
            const ok = await confirmModal("Witch save was already used in a previous night. Use again?");
            if (!ok) return;
          }
          state.night.witchSaveId = id;
          state.night.witchSaved = true;
          state.night.witchSaveUsed = true;
          state.day.witchSaveLastUseNight = state.night.number;
          renderNight();
        };
        savePick.appendChild(btn);
      });
    } else {
      const info = document.createElement("div");
      info.className = "mini muted";
      info.textContent = "No one to save.";
      savePick.appendChild(info);
    }

    const pick = $("witchKillPick");
    pick.innerHTML = "";
    state.players.forEach(p => {
      const b = document.createElement("button");
      b.className = "playerBtn" + (p.alive ? "" : " dead");
      if (isEvilRole(p.role)) b.classList.add("evil");
      if (p.role === ROLE.WITCH) b.classList.add("roleHighlight");
      b.disabled = !p.alive || !witchAlive;
      const chosen = state.night.witchKillId === p.id;
      b.style.outline = chosen ? "2px solid rgba(255,91,110,.8)" : "";
      const roleLabel = escapeHtml(getDisplayRole(p));
      b.innerHTML = `<span class="name"><b>${p.id}.</b> ${escapeHtml(p.name)}</span><span class="mini">${roleLabel}${chosen ? " • target" : ""}</span>`;
      b.onclick = async () => {
        if (!witchAlive) return;
        if (state.night.witchKillId === p.id){
          state.night.witchKillId = null;
        } else {
          if (deathOutOfUse){
            const ok = await confirmModal("Kill potion already used in a previous night. Use again?");
            if (!ok) return;
          }
          state.night.witchKillId = p.id;
          state.night.witchKillUsed = true;
          state.day.witchKillLastUseNight = state.night.number;
        }
        renderNight();
      };
      pick.appendChild(b);
    });
  }

  function renderHunterPanel(panel){
    const hunterAlive = isRoleAlive(ROLE.HUNTER);
    panel.innerHTML = `
      ${selectionSummary(state.night.hunterMarkId ? [state.night.hunterMarkId] : [], 1)}
      <div id="hunterPick" class="grid"></div>
      </div>
    `;
    const pick = $("hunterPick");
    state.players.forEach(p => {
      const b = document.createElement("button");
      b.className = "playerBtn" + (p.alive ? "" : " dead");
      if (isEvilRole(p.role)) b.classList.add("evil");
      if (p.role === ROLE.HUNTER) b.classList.add("roleHighlight");
      b.disabled = !p.alive || !hunterAlive;
      const chosen = state.night.hunterMarkId === p.id;
      b.style.outline = chosen ? "2px solid rgba(255,209,102,.8)" : "";
      const roleLabel = escapeHtml(getDisplayRole(p));
      b.innerHTML = `<span class="name"><b>${p.id}.</b> ${escapeHtml(p.name)}</span><span class="mini">${roleLabel}${chosen ? " • marked" : ""}</span>`;
      b.onclick = () => { if (!hunterAlive) return; state.night.hunterMarkId = p.id; renderNight(); };
      pick.appendChild(b);
    });
  }

  // ----- Announce / Win (AUTO) -----
  function announce(text){
    // append to dayAnnouncements area when visible; also store in state
    state.day.announcements.push(text);
    if ($("dayAnnouncements")) $("dayAnnouncements").textContent = state.day.announcements.join("\n");
  }

  function selectionSummary(ids, max){
    const names = (ids || []).map(labelPlayer).filter(Boolean);
    const shown = names.length ? names.join(", ") : "—";
    return `<div class="mini selectionSummary">Selected <b>${names.length}</b>/<b>${max}</b>: ${shown}</div>`;
  }

  function recordDayLog(){
    const dayNum = state.night.number;
    const entry = {
      day: dayNum,
      nightLog: [...state.day.lastNightLog],
      dayAnnouncements: [...state.day.announcements],
    };
    const idx = state.day.history.findIndex(x => x.day === dayNum);
    if (idx >= 0) state.day.history[idx] = entry;
    else state.day.history.push(entry);
  }

  function buildWinnerDetails(baseDetails){
    const details = [...baseDetails];

    const alive = state.players.filter(p => p.alive);
    const dead = state.players.filter(p => !p.alive);
    details.push("");
    details.push("Alive players:");
    if (!alive.length) details.push("None");
    else alive.forEach(p => details.push(`${p.name}: ${getDisplayRole(p)}`));
    details.push("");
    details.push("Dead players:");
    if (!dead.length) details.push("None");
    else dead.forEach(p => details.push(`${p.name}: ${getDisplayRole(p)}`));

    recordDayLog();
    if (state.day.history.length){
      details.push("");
      details.push("Day logs:");
      const sorted = state.day.history.slice().sort((a,b)=>a.day-b.day);
      for (const d of sorted){
        details.push(`Day ${d.day}`);
        details.push(`Night:`);
        if (d.nightLog.length) d.nightLog.forEach(l => details.push(`- ${l}`));
        else details.push(`- —`);
        details.push(`Day:`);
        if (d.dayAnnouncements.length) d.dayAnnouncements.forEach(l => details.push(`- ${l}`));
        else details.push(`- —`);
        details.push("");
      }
    }

    return details;
  }

  function countAliveEvil(){ return state.players.filter(p => p.alive && isEvilRole(p.role)).length; }
  function countAliveNonEvil(){ return state.players.filter(p => p.alive && !isEvilRole(p.role)).length; }

  function setWinner(type, title, details){
    recordDayLog();
    state.winner = {type, title, details};
    $("winnerTitle").textContent = title;
    $("winnerDetails").textContent = buildWinnerDetails(details).join("\n");
    showScreen(7);
    saveState();
    return state.winner;
  }

  function checkWinAuto(context = { kind: "generic" }){
    // Tanner special: ONLY if lynched
    if (context.kind === "voteKill" && context.playerId){
      const p = state.players.find(x => x.id === context.playerId);
      if (p && p.role === ROLE.SOBER && !p.alive){
        return setWinner("Tanner", "Tanner wins", [`Tanner (${labelPlayerWithRole(p.id)}) was lynched.`]);
      }
    }

    // Couple third-party win: only if couple are the last survivors and on different sides
    if (state.day.coupleIds && state.day.coupleIds.length === 2){
      const [aId, bId] = state.day.coupleIds;
      const a = state.players.find(x => x.id === aId);
      const b = state.players.find(x => x.id === bId);
      const alivePlayers = state.players.filter(p => p.alive);
      if (a && b && a.alive && b.alive && alivePlayers.length === 2){
        const aEvil = isEvilRole(a.role);
        const bEvil = isEvilRole(b.role);
        if (aEvil !== bEvil){
          return setWinner("Couple", "Couple wins", [
            `Couple survived as the last two players.`,
            `${a.name}: ${getDisplayRole(a)}`,
            `${b.name}: ${getDisplayRole(b)}`,
          ]);
        }
      }
    }

    const aliveEvil = countAliveEvil();
    const aliveNonEvil = countAliveNonEvil();

    if (aliveEvil > 0 && aliveEvil === aliveNonEvil){
      return setWinner("Wolves", "Wolves win", [
        `Alive wolves: ${aliveEvil}`,
        `Alive non-wolves: ${aliveNonEvil}`,
        `Rule: wolves == non-wolves → wolves win`
      ]);
    }
    if (aliveEvil === 0){
      return setWinner("Villagers", "Villagers win", [`All wolves are dead.`]);
    }
    return null;
  }

  // ----- Resolve night -> day -----
  function appendNightLog(line){
    state.day.lastNightLog.push(line);
    $("nightLog").textContent = state.day.lastNightLog.join("\n");
  }

  function resolveNight(){
    const tmPending = state.day.troublemakerPendingNextDay;
    recordDayLog();
    const pendingToughGuy = state.day.pendingToughGuyId;
    const pendingToughGuyNight = state.day.pendingToughGuyNight;
    const pendingDireWolf = state.day.pendingDireWolfId;
    const pendingDireWolfNight = state.day.pendingDireWolfNight;
    state.day.lastNightLog = [];
    state.day.announcements = [];
    state.day.lynchCount = 0;
    state.day.lynchWarned = false;
    state.day.troublemakerActiveToday = !!tmPending;
    state.day.troublemakerPendingNextDay = false;
    state.day.silencedId = null;

    const bites = [...state.night.bites];
    const bg = state.night.bodyguardId;
    state.day.lastBodyguardId = bg || null;

    appendNightLog(`Wolves bit ${bites.length ? bites.map(labelPlayerWithRole).join(", ") : "no one"}`);
    if (bg) appendNightLog(`Bodyguard protected ${labelPlayerWithRole(bg)}`);
    if (state.night.sorceressInspectId) appendNightLog(`Sorceress inspected ${labelPlayerWithRole(state.night.sorceressInspectId)} => ${state.night.sorceressResult || "—"}`);
    if (state.night.seerInspectId) appendNightLog(`Seer inspected ${labelPlayerWithRole(state.night.seerInspectId)} => ${state.night.seerResult || "—"}`);
    if (state.night.apprenticeInspectId) appendNightLog(`Apprentice Seer inspected ${labelPlayerWithRole(state.night.apprenticeInspectId)} => ${state.night.apprenticeResult || "—"}`);
    if (state.night.spellcasterTargetId) appendNightLog(`Spellcaster silenced ${labelPlayerWithRole(state.night.spellcasterTargetId)} for today`);
    if (state.night.piChecked){
      const list = state.night.piSelectedIds.map(labelPlayerWithRole).join(", ") || "—";
      const tag = state.night.piSecondUse ? " (SECOND USE)" : "";
      appendNightLog(`P.I. checked ${list} => ${state.night.piResult || "—"}${tag}`);
    }
    if (state.night.number === 1 && state.roles[ROLE.CUPID] > 0 && state.night.cupidSelectedIds.length === 2){
      appendNightLog(`Cupid linked ${state.night.cupidSelectedIds.map(labelPlayerWithRole).join(", ")}.`);
    }
    if (state.night.number === 1 && state.roles[ROLE.DOPPELGANGER] > 0 && state.day.doppelgangerTargetId){
      appendNightLog(`Doppelganger chose ${labelPlayerWithRole(state.day.doppelgangerTargetId)}.`);
    }
    if (state.night.number === 1 && state.roles[ROLE.DIRE_WOLF] > 0 && state.day.direWolfTargetId){
      appendNightLog(`Dire Wolf chose ${labelPlayerWithRole(state.day.direWolfTargetId)}.`);
    }
    if (state.night.number > 1 && (state.day.doppelgangerPendingRole || state.day.doppelgangerRole)){
      appendNightLog(`Doppelganger learned the eliminated role: ${state.day.doppelgangerPendingRole || state.day.doppelgangerRole}.`);
    }
    if (tmPending){
      appendNightLog(`Troublemaker activated: 2 lynches allowed today.`);
    }

    if (state.night.spellcasterTargetId){
      state.day.silencedId = state.night.spellcasterTargetId;
      announce(`${labelPlayer(state.night.spellcasterTargetId)} must not speak today.`);
    }

    // Effective bites after bodyguard
    let bittenEffective = bites.filter(id => id !== bg);

    // Diseased effect: wolves skip feeding this night
    if (state.day.skipWolfBiteNextNight){
      appendNightLog(`Wolves skip feeding due to Diseased (no bite deaths).`);
      bittenEffective = [];
      state.day.skipWolfBiteNextNight = false;
    }

    // Witch save (saves ONE target)
    if (state.night.witchSaveId){
      appendNightLog(`Witch protected ${labelPlayerWithRole(state.night.witchSaveId)}`);
      bittenEffective = bittenEffective.filter(id => id !== state.night.witchSaveId);
    }

    // Tough Guy delayed death (from prior night)
    const forcedDeaths = new Set();
    if (pendingToughGuy && pendingToughGuyNight != null && pendingToughGuyNight < state.night.number){
      const p = state.players.find(x => x.id === pendingToughGuy);
      if (p && p.alive){
        appendNightLog(`Tough Guy ${labelPlayerWithRole(pendingToughGuy)} succumbed to wounds.`);
        forcedDeaths.add(pendingToughGuy);
      }
      state.day.pendingToughGuyId = null;
      state.day.pendingToughGuyNight = null;
    }
    if (pendingDireWolf && pendingDireWolfNight != null && pendingDireWolfNight < state.night.number){
      const p = state.players.find(x => x.id === pendingDireWolf);
      if (p && p.alive){
        appendNightLog(`Dire Wolf succumbed to the pact and died.`);
        forcedDeaths.add(pendingDireWolf);
      }
      state.day.pendingDireWolfId = null;
      state.day.pendingDireWolfNight = null;
    }

    // If Tough Guy is bitten tonight (and not saved), delay death
    const toughGuyId = bittenEffective.find(id => {
      const p = state.players.find(x => x.id === id);
      return p && p.alive && p.role === ROLE.TOUGH_GUY;
    });
    if (toughGuyId){
      bittenEffective = bittenEffective.filter(id => id !== toughGuyId);
      state.day.pendingToughGuyId = toughGuyId;
      state.day.pendingToughGuyNight = state.night.number;
      appendNightLog(`Tough Guy ${labelPlayerWithRole(toughGuyId)} is wounded and will die tomorrow.`);
    }

    // If Diseased is eaten (and not saved), wolves skip next night
    const diseasedEaten = bittenEffective.some(id => {
      const p = state.players.find(x => x.id === id);
      return p && p.alive && p.role === ROLE.DISEASED;
    });
    if (diseasedEaten){
      state.day.skipWolfBiteNextNight = true;
      appendNightLog(`Diseased was eaten; wolves will skip feeding next night.`);
    }

    // Witch kill (cannot be bodyguarded)
    const witchKill = (state.night.witchKillUsed && state.night.witchKillId) ? state.night.witchKillId : null;
    if (witchKill) appendNightLog(`Witch killed ${labelPlayerWithRole(witchKill)}`);

    // Death set
    const deathSet = new Set();
    forcedDeaths.forEach(id => deathSet.add(id));
    bittenEffective.forEach(id => deathSet.add(id));
    if (witchKill) deathSet.add(witchKill);

    // Dire Wolf: if target dies at night, Dire Wolf dies too
    if (state.day.direWolfTargetId && deathSet.has(state.day.direWolfTargetId)){
      const dw = state.players.find(p => p.role === ROLE.DIRE_WOLF && p.alive);
      if (dw) deathSet.add(dw.id);
      appendNightLog(`Dire Wolf died with ${labelPlayerWithRole(state.day.direWolfTargetId)}.`);
    }

    // Priest protection (wolf bites only)
    if (state.night.priestProtectId){
      bittenEffective = bittenEffective.filter(id => id !== state.night.priestProtectId);
      appendNightLog(`Priest protected ${labelPlayerWithRole(state.night.priestProtectId)} from bites`);
      state.night.priestProtectId = null;
    }

    // Hunter chain (night death)
    const hunter = state.players.find(p => p.role === ROLE.HUNTER);
    const hunterDied = hunter && deathSet.has(hunter.id);
    state.night.hunterDied = !!hunterDied;
    if (hunterDied && state.night.hunterMarkId){
      deathSet.add(state.night.hunterMarkId);
      appendNightLog(`Hunter died; took ${labelPlayerWithRole(state.night.hunterMarkId)} with him`);
    }

    // Couple chain at night (immediate)
    if (state.day.coupleIds && state.day.coupleIds.length === 2){
      const [aId, bId] = state.day.coupleIds;
      if (deathSet.has(aId) && !deathSet.has(bId)) {
        deathSet.add(bId);
        appendNightLog(`Couple: ${labelPlayerWithRole(bId)} died of heartbreak.`);
      }
      if (deathSet.has(bId) && !deathSet.has(aId)) {
        deathSet.add(aId);
        appendNightLog(`Couple: ${labelPlayerWithRole(aId)} died of heartbreak.`);
      }
    }

    // Day-triggered couple death scheduled for next night
    if (state.day.pendingCoupleId){
      const pid = state.day.pendingCoupleId;
      const p = state.players.find(x => x.id === pid);
      if (p && p.alive){
        deathSet.add(pid);
        appendNightLog(`Couple: ${labelPlayerWithRole(pid)} died of heartbreak.`);
      }
      state.day.pendingCoupleId = null;
    }

    // Hunter lynched last day -> marked dies next morning
    if (state.day.pendingHunterMarkId){
      deathSet.add(state.day.pendingHunterMarkId);
      appendNightLog(`Hunter was lynched; marked ${labelPlayerWithRole(state.day.pendingHunterMarkId)} died at dawn`);
      state.day.pendingHunterMarkId = null;
    }

    const nightDeaths = [...deathSet].filter(id => {
      const p = state.players.find(x => x.id === id);
      return p && p.alive;
    });

    nightDeaths.forEach(id => {
      const p = state.players.find(x => x.id === id);
      if (p) p.alive = false;
    });
    nightDeaths.forEach(id => {
      const p = state.players.find(x => x.id === id);
      if (p) markDoppelgangerTargetDeath(p);
    });

    state.day.dayDeaths = nightDeaths;
    state.day.lastNightDeaths = nightDeaths;
    // wolf cub bonus for NEXT night only if wolf cub died tonight
    state.day.wolfCubDiedLastDay = nightDeaths.some(id => {
      const p = state.players.find(x => x.id === id);
      return p && p.role === ROLE.WOLFCUB;
    });

    if (nightDeaths.length){
      announce(`${nightDeaths.map(labelPlayer).join(", ")} died.`);
    } else {
      announce(`No one died.`);
    }

    // AUTO win check after applying deaths
    checkWinAuto();
    saveState();
  }

  // ----- Voting / Manual kill -----
  function killPlayer(id, reason){
    const p = state.players.find(x => x.id === id);
    if (!p || !p.alive) return false;
    p.alive = false;
    markDoppelgangerTargetDeath(p);
    if (state.day.direWolfTargetId === p.id){
      const dw = state.players.find(x => x.role === ROLE.DIRE_WOLF && x.alive);
      if (dw){
        state.day.pendingDireWolfId = dw.id;
        state.day.pendingDireWolfNight = state.night.number;
        announce(`Dire Wolf will die tonight due to ${labelPlayer(p.id)}.`); 
      }
    }

    // wolf cub bonus: only if died during DAY (vote/manual)
    if (reason === "vote" || reason === "manual"){
      state.day.wolfCubDiedLastDay = (p.role === ROLE.WOLFCUB);
    }

    // Day-triggered couple death scheduled for next night
    if (state.day.coupleIds && state.day.coupleIds.length === 2){
      const [aId, bId] = state.day.coupleIds;
      const partnerId = (p.id === aId) ? bId : (p.id === bId ? aId : null);
      if (partnerId){
        state.day.pendingCoupleId = partnerId;
        announce(`${labelPlayer(partnerId)} will die of heartbreak tonight.`);
      }
    }

    saveState();
    return true;
  }

  // ----- Vote Screen -----
  function renderVote(){
    renderPlayersGrid("playersGridVote", {
      disableDeadClick: true,
      onClick: (p) => {
        state.vote.selectedId = p.id;
        $("voteSelectedLabel").textContent = labelPlayer(p.id);
        renderVote();
      }
    });

    // highlight selection
    for (const btn of $("playersGridVote").querySelectorAll("button")){
      const txt = btn.querySelector(".name")?.textContent || "";
      const id = parseInt(txt.split(".")[0],10);
      if (id === state.vote.selectedId){
        btn.style.outline = "2px solid rgba(255,209,102,.85)";
      }
    }

    $("lynchTimerText").textContent = fmtTime(state.vote.timer);
    saveState();
  }

  // ----- Manual Screen -----
  function renderManual(){
    renderPlayersGrid("playersGridManual", {
      disableDeadClick:false,
      onClick: (p) => {
        // toggle alive/dead
        const wasAlive = p.alive;
        p.alive = !p.alive;
        if (!p.alive) markDoppelgangerTargetDeath(p);

        // day-kill logic for wolf cub bonus if we killed them manually
        if (wasAlive && !p.alive) state.day.wolfCubDiedLastDay = (p.role === ROLE.WOLFCUB);

        // AUTO win check whenever admin changes state
        checkWinAuto();

        // log manual action
        announce(`${labelPlayer(p.id)} was ${p.alive ? "revived" : "killed"} manually.`);

        renderManual();
        // also refresh night UI if they go back
      }
    });
    saveState();
  }

  function renderRevealScreen(data){
    const list = $("revealList");
    if (!list) return;
    list.innerHTML = "";
    const revealed = new Set();
    const players = data.p || data.players || [];
    const roleColorClass = (roleName) => {
      if (roleMeta[roleName]?.side === SIDE.EVIL) return "bad";
      if (roleMeta[roleName]?.side === SIDE.OTHER) return "other";
      return "";
    };
    players.forEach((p, idx) => {
      const b = document.createElement("button");
      b.className = "playerBtn";
      const name = p.n || p.name || `Player ${idx+1}`;
      b.innerHTML = `<span class="name"><b>${idx+1}.</b> ${escapeHtml(name)}</span><span class="mini">—</span>`;
      b.onclick = () => {
        const role = p.r != null ? idToRole(p.r) : (p.role || "—");
        confirmModal(`Reveal ${name}'s role? Make sure you are ${name} or already dead.`).then(async ok => {
          if (!ok) return;
          const cls = roleColorClass(role);
          b.classList.remove("evil","other");
          if (cls === "bad") b.classList.add("evil");
          if (cls === "other") b.classList.add("other");
          b.querySelector(".mini").textContent = role;
          await showModal({title:"", message:`${name} is ${role}`, confirmText:"OK", bigMessage:true});
        });
      };
      list.appendChild(b);
    });

    const revealAllBtn = $("revealAllBtn");
    if (revealAllBtn){
      revealAllBtn.onclick = async () => {
        const ok = await confirmModal("Do you want to reveal roles of all players?");
        if (!ok) return;
        const buttons = list.querySelectorAll("button");
        players.forEach((p, idx) => {
          const role = p.r != null ? idToRole(p.r) : (p.role || "—");
          const cls = roleColorClass(role);
          const btn = buttons[idx];
          btn.classList.remove("evil","other");
          if (cls === "bad") btn.classList.add("evil");
          if (cls === "other") btn.classList.add("other");
          const mini = btn.querySelector(".mini");
          mini.textContent = role;
        });
      };
    }
    const revealSummaryBtn = $("revealSummaryBtn");
    if (revealSummaryBtn){
      revealSummaryBtn.onclick = async () => {
        const countBySide = { evil: {}, good: {}, other: {} };
        players.forEach(p => {
          const role = p.r != null ? idToRole(p.r) : (p.role || "—");
          const side = roleMeta[role]?.side || SIDE.GOOD;
          const bucket = side === SIDE.EVIL ? "evil" : side === SIDE.OTHER ? "other" : "good";
          countBySide[bucket][role] = (countBySide[bucket][role] || 0) + 1;
        });
        const fmtList = (obj) => {
          const entries = Object.entries(obj);
          if (!entries.length) return "-";
          return entries.map(([r,c]) => `- ${c} ${r}`).join("\n");
        };
        const evilTotal = Object.values(countBySide.evil).reduce((s,v)=>s+v,0);
        const goodTotal = Object.values(countBySide.good).reduce((s,v)=>s+v,0);
        const otherTotal = Object.values(countBySide.other).reduce((s,v)=>s+v,0);

        const left =
          `<div class="summaryTitle">Evil (${evilTotal}):</div>` +
          `<div class="summaryList">${fmtList(countBySide.evil)}</div>` +
          `<div class="summaryTitle" style="margin-top:10px">Other (${otherTotal}):</div>` +
          `<div class="summaryList">${fmtList(countBySide.other)}</div>`;
        const right =
          `<div class="summaryTitle">Good (${goodTotal}):</div>` +
          `<div class="summaryList">${fmtList(countBySide.good)}</div>`;
        const html = `<div class="roleSummaryCols"><div>${left}</div><div>${right}</div></div>`;
        await showModal({title:"Role Summary", message: html, confirmText:"OK", bigMessage:false, html:true});
      };
    }
  }

  async function handleRevealFromUrl(){
    const params = new URLSearchParams(window.location.search);
    let token = params.get("RI");
    if (!token && window.location.hash){
      const hashParams = new URLSearchParams(window.location.hash.replace(/^#/, ""));
      token = hashParams.get("RI");
    }
    if (token) token = token.trim().replace(/\s/g, "");
    if (!token) return false;
    try {
      const data = await decryptRoomInfo(token);
      if (!data || !(Array.isArray(data.players) || Array.isArray(data.p))) return false;
      renderRevealScreen(data);
      showScreen("s8");
      return true;
    } catch {
      return false;
    }
  }

  // ----- Timers -----
  function startDayTimer(){
    if (state.timers.dayInterval) return;
    state.timers.dayInterval = setInterval(() => {
      state.timers.day++;
      $("dayTimerText").textContent = fmtTime(state.timers.day);
    }, 1000);
  }
  function stopDayTimer(){
    if (state.timers.dayInterval){
      clearInterval(state.timers.dayInterval);
      state.timers.dayInterval = null;
    }
  }
  function startVoteTimer(){
    if (state.vote.interval) return;
    state.vote.interval = setInterval(() => {
      state.vote.timer++;
      $("lynchTimerText").textContent = fmtTime(state.vote.timer);
    }, 1000);
  }
  function stopVoteTimer(){
    if (state.vote.interval){
      clearInterval(state.vote.interval);
      state.vote.interval = null;
    }
  }

  // ----- Flow -----
  function startGameFromAssignedRoles(){
    // hard safety: ensure everyone has a role (default villager)
    state.players.forEach(p => {
      if (!p.role) p.role = ROLE.VILLAGER;
      p.role = normalizeRole(p.role);
      if (p.role === ROLE.DOPPELGANGER && !p.baseRole) p.baseRole = ROLE.DOPPELGANGER;
    });

    state.gameStarted = true;
    state.winner = null;

    // reset all alive
    state.players.forEach(p => p.alive = true);

    // reset logs/timers
    state.day.lastNightLog = [];
    state.day.announcements = [];
    state.day.wolfCubDiedLastDay = false;
    state.day.pendingHunterMarkId = null;
    state.day.lynchCount = 0;
    state.day.lynchWarned = false;
    state.day.lastBodyguardId = null;
    state.day.skipWolfBiteNextNight = false;
    state.day.troublemakerUsed = false;
    state.day.troublemakerActiveToday = false;
    state.day.troublemakerPendingNextDay = false;
    state.day.troublemakerLastUseNight = null;
    state.day.pendingToughGuyId = null;
    state.day.pendingToughGuyNight = null;
    state.day.piUses = 0;
    state.day.piLastUseNight = null;
    state.day.witchSaveLastUseNight = null;
    state.day.witchKillLastUseNight = null;
    state.day.history = [];
    state.day.coupleIds = null;
    state.day.pendingCoupleId = null;
    state.day.silencedId = null;
    state.day.priestLastUseNight = null;
    state.day.doppelgangerTargetId = null;
    state.day.doppelgangerPendingRole = null;
    state.day.doppelgangerRole = null;
    state.day.direWolfTargetId = null;
    state.day.pendingDireWolfId = null;
    state.day.pendingDireWolfNight = null;
    state.day.doppelgangerTargetId = null;
    state.day.doppelgangerPendingRole = null;
    state.day.doppelgangerRole = null;
    state.day.direWolfTargetId = null;
    state.day.pendingDireWolfId = null;
    state.day.pendingDireWolfNight = null;
    state.night.priestProtectId = null;
    state.night.priestUsed = false;

    stopDayTimer(); state.timers.day = 0; $("dayTimerText").textContent = "00:00";
    stopVoteTimer(); state.vote.timer = 0; $("lynchTimerText").textContent = "00:00";

    // reset night
    state.night.number = 1;
    resetNightState({keepPotions:false});

    renderNight();
    showScreen(3);
  }

  function goToNextNight(){
    // Start next night clean, steps reset to wolf (bug fix)
    recordDayLog();
    state.night.number++;
    state.day.lastNightLog = [];
    state.day.announcements = [];
    $("nightLog").textContent = "";
    $("dayAnnouncements").textContent = "";

    // Keep potion usage across nights (typical), but your spec didn't say;
    // If you want per-night reset, set keepPotions=false.
    resetNightState({keepPotions:true});
    const dgRole = applyDoppelgangerPendingRole();
    if (dgRole) appendNightLog(`Doppelganger became ${dgRole}.`);

    renderNight();
    showScreen(3);
  }

  function resetToDefaults(){
    stopDayTimer(); stopVoteTimer();
    state.playerCount = 10;
    state.players = Array.from({length: state.playerCount}, (_,i)=>({
      id:i+1, name:`Player ${i+1}`, alive:true, role:ROLE.VILLAGER, baseRole:null
    }));
    state.roles = { ...defaultRoles };
    state.gameStarted = false;
    state.winner = null;

    state.day.lastNightLog = [];
    state.day.announcements = [];
    state.day.dayDeaths = [];
    state.day.wolfCubDiedLastDay = false;
    state.day.pendingHunterMarkId = null;
    state.day.lynchCount = 0;
    state.day.lynchWarned = false;
    state.day.lastBodyguardId = null;
    state.day.skipWolfBiteNextNight = false;
    state.day.troublemakerUsed = false;
    state.day.troublemakerActiveToday = false;
    state.day.troublemakerPendingNextDay = false;
    state.day.troublemakerLastUseNight = null;
    state.day.pendingToughGuyId = null;
    state.day.pendingToughGuyNight = null;
    state.day.piUses = 0;
    state.day.piLastUseNight = null;

    state.vote.selectedId = null;
    state.vote.timer = 0;

    state.timers.day = 0;
    $("dayTimerText").textContent = "00:00";
    $("lynchTimerText").textContent = "00:00";

    state.night.number = 1;
    resetNightState({keepPotions:false});

    renderPlayersTextarea();
    applyPlayersFromTextarea();
    renderRoleTables();
    updateQuickStatus();
    showScreen(1);
    const resumeCard = $("resumeCard");
    if (resumeCard) resumeCard.style.display = "none";
    saveState();
  }

  // ----- Init -----
  async function init(){
    saveSuppressed = true;
    // init players
    state.playerCount = 10;
    state.players = Array.from({length: state.playerCount}, (_,i)=>({id:i+1,name:`Player ${i+1}`,alive:true,role:ROLE.VILLAGER,baseRole:null}));
    renderPlayersTextarea();
    applyPlayersFromTextarea();
    renderRoleTables();
    updateQuickStatus();

    const saved = loadSavedState();
    if (saved){
      applySnapshot(saved.snapshot);
      renderPlayersTextarea();
      renderRoleTables();
      updateQuickStatus();
      saveSuppressed = true;
      showScreen(1);
      saveSuppressed = false;
      $("resumeCard").style.display = "block";
      const savedCount = (saved.snapshot?.players || []).length || saved.snapshot?.playerCount || 0;
      $("resumeBtn").textContent = `Resume last game (${savedCount} people)`;
      $("resumeBtn").onclick = () => {
        const latest = loadSavedState();
        if (!latest) return;
        applySnapshot(latest.snapshot);
        restoreUIForScreen(latest.activeScreen);
      };
    }
    saveSuppressed = false;
    if (!saved) saveState();

    await handleRevealFromUrl();

    // Screen 1
    $("playersTextarea").addEventListener("input", () => {
      applyPlayersFromTextarea();
      renderRoleTables();
      updateQuickStatus();
    });
    $("clearPlayersBtn").onclick = () => {
      $("playersTextarea").value = "";
      applyPlayersFromTextarea();
      renderRoleTables();
      updateQuickStatus();
    };

    // Menu
    const sidePanel = $("sidePanel");
    const overlay = $("overlay");
    const closeMenu = () => {
      sidePanel.classList.remove("open");
      overlay.classList.remove("show");
    };
    $("menuBtn").onclick = () => {
      sidePanel.classList.toggle("open");
      overlay.classList.toggle("show");
    };
    overlay.onclick = closeMenu;
    $("aboutBtn").onclick = async () => {
      closeMenu();
      await alertModal("Hehe, that's quantran", "About");
    };
    $("resetGameBtn").onclick = () => {
      stopDayTimer(); stopVoteTimer();
      if (location.search || location.hash){
        history.replaceState(null, "", location.pathname);
      }
      state.players.forEach(p => p.alive = true);
      // keep configured roles
      state.gameStarted = false;
      state.winner = null;

      state.day.lastNightLog = [];
      state.day.announcements = [];
      state.day.dayDeaths = [];
      state.day.wolfCubDiedLastDay = false;
      state.day.pendingHunterMarkId = null;
      state.day.lynchCount = 0;
      state.day.lynchWarned = false;
      state.day.lastBodyguardId = null;
      state.day.skipWolfBiteNextNight = false;
      state.day.troublemakerUsed = false;
      state.day.troublemakerActiveToday = false;
      state.day.troublemakerPendingNextDay = false;
      state.day.troublemakerLastUseNight = null;
      state.day.pendingToughGuyId = null;
      state.day.pendingToughGuyNight = null;
      state.day.piUses = 0;
      state.day.piLastUseNight = null;
      state.day.witchSaveLastUseNight = null;
      state.day.witchKillLastUseNight = null;
      state.day.history = [];
      state.day.coupleIds = null;
      state.day.pendingCoupleId = null;
      state.day.silencedId = null;
      state.day.priestLastUseNight = null;
      state.day.doppelgangerTargetId = null;
      state.day.doppelgangerPendingRole = null;
      state.day.doppelgangerRole = null;
      state.day.direWolfTargetId = null;
      state.day.pendingDireWolfId = null;
      state.day.pendingDireWolfNight = null;
    state.day.doppelgangerTargetId = null;
    state.day.doppelgangerPendingRole = null;
    state.day.doppelgangerRole = null;
    state.day.direWolfTargetId = null;
    state.day.pendingDireWolfId = null;
    state.day.pendingDireWolfNight = null;
      state.night.priestProtectId = null;
      state.night.priestUsed = false;

      state.vote.selectedId = null;
      state.vote.timer = 0;
      state.timers.day = 0;
      $("dayTimerText").textContent = "00:00";
      $("lynchTimerText").textContent = "00:00";

      state.night.number = 1;
      resetNightState({keepPotions:false});

      renderPlayersTextarea();
      renderRoleTables();
      updateQuickStatus();
      showScreen(1);
      saveState();
      closeMenu();
    };

    $("playBtn").onclick = async () => {
      applyPlayersFromTextarea();
      showScreen(2);
    };

    // Screen 2
    $("backToS1Btn").onclick = () => showScreen(1);
    $("toAssignRolesBtn").onclick = async () => {
      applyPlayersFromTextarea();
      const cap = state.playerCount || state.players.length || 0;
      if (cap > 0 && roleTotal() !== cap){
        const msg = roleTotal() > cap
          ? `You have more roles than players. (${roleTotal()} / ${cap})`
          : `You have fewer roles than players. (${roleTotal()} / ${cap})`;
        await alertModal(msg);
        return;
      }
      showScreen("s25");
      autoFillRolesRandom();
      renderAssignRoles();
    };

    // Screen 2.5
    $("backToRoleConfigBtn").onclick = () => showScreen(2);
    $("autoFillRolesBtn").onclick = () => autoFillRolesRandom();
    $("clearRolesBtn").onclick = () => clearRoles();
    $("startGameBtn").onclick = () => startGameFromAssignedRoles();
    const showRoleSummary = async () => {
      const fmtList = (roles) => roles
        .filter(r => (state.roles[r] || 0) > 0)
        .map(r => `- ${state.roles[r]} ${r}`)
        .join("\n") || "-";

      const evilRoles = [ROLE.WEREWOLF, ROLE.SORCERESS, ROLE.WOLFCUB, ROLE.DIRE_WOLF, ROLE.FRUIT_WOLF];
      const goodRoles = Object.keys(state.roles).filter(r => roleMeta[r]?.side === SIDE.GOOD);
      const otherRoles = Object.keys(state.roles).filter(r => roleMeta[r]?.side === SIDE.OTHER);

      const evilTotal = evilRoles.reduce((s,r)=>s+(state.roles[r]||0),0);
      const goodTotal = goodRoles.reduce((s,r)=>s+(state.roles[r]||0),0);
      const otherTotal = otherRoles.reduce((s,r)=>s+(state.roles[r]||0),0);

      const left =
        `<div class="summaryTitle">Evil (${evilTotal}):</div>` +
        `<div class="summaryList">${fmtList(evilRoles)}</div>` +
        `<div class="summaryTitle" style="margin-top:10px">Other (${otherTotal}):</div>` +
        `<div class="summaryList">${fmtList(otherRoles)}</div>`;
      const right =
        `<div class="summaryTitle">Good (${goodTotal}):</div>` +
        `<div class="summaryList">${fmtList(goodRoles)}</div>`;

      const html = `<div class="roleSummaryCols"><div>${left}</div><div>${right}</div></div>`;
      await showModal({title:"Role Summary", message: html, confirmText:"OK", bigMessage:false, html:true});
    };
    $("roleSummaryBtn").onclick = showRoleSummary;
    $("roleSummaryBtnConfig").onclick = showRoleSummary;
    $("getRevealLinkBtn").onclick = async () => {
      const payload = {
        p: state.players.map(p => ({ n: p.name, r: roleToId(p.role) }))
      };
      console.log("Reveal payload", payload);
      const token = await encryptRoomInfo(payload);
      const url = buildRevealUrl(token);
      const qrUrl = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(url)}`;
      const html =
        `<div class="summaryTitle">Link</div>` +
        `<div class="summaryList"><a href="${url}" target="_blank" rel="noopener noreferrer">${escapeHtml(url)}</a></div>` +
        `<div class="summaryTitle" style="margin-top:10px">Scan QR</div>` +
        `<div style="display:flex;justify-content:center;margin-top:6px"><img src="${qrUrl}" alt="QR"/></div>`;
      await showModal({title:"Reveal Roles Link", message: html, confirmText:"OK", bigMessage:false, html:true});
    };

    // Night navigation
    $("nightPrevBtn").onclick = () => { state.night.stepIndex--; renderNight(); };
    $("nightNextBtn").onclick = () => {
      const lastIdx = Math.max(0, state.night.steps.length - 1);
      if (state.night.stepIndex >= lastIdx){
        $("toDayBtn").click();
        return;
      }
      state.night.stepIndex++;
      renderNight();
    };

    $("toDayBtn").onclick = async () => {
      const lastIdx = Math.max(0, state.night.steps.length - 1);
      if (state.night.stepIndex < lastIdx){
        const ok = await confirmModal("Not at the last night step. End this night anyway?");
        if (!ok) return;
      }
      resolveNight();
      // Show day (if winner was found, we already switched to Screen 7)
      if (state.winner) return;
      $("nightLog").textContent = state.day.lastNightLog.join("\n");
      $("dayAnnouncements").textContent = state.day.announcements.join("\n");
      showScreen(4);
    };

    $("toManualBtn").onclick = () => {
      renderManual();
      showScreen(6);
    };

    // Day screen
    $("toVoteBtn").onclick = async () => {
      if (state.day.lynchCount >= 1 && !(state.day.troublemakerActiveToday && state.day.lynchCount === 1)){
        const ok = await confirmModal(`Already lynched ${state.day.lynchCount} time(s) today. Continue?`);
        if (!ok) return;
      }
      state.vote.selectedId = null;
      stopVoteTimer(); state.vote.timer = 0;
      $("voteSelectedLabel").textContent = "—";
      renderVote();
      showScreen(5);
    };



    $("toNextNightBtn").onclick = () => {
      // Going back to night ALWAYS resets to wolf step (bug fix)
      goToNextNight();
    };

    $("killByVoteBtn").onclick = async () => {
      if (!state.vote.selectedId){ await alertModal("Pick a player first."); return; }
      if (state.day.lynchCount >= 2){
        const ok = await confirmModal("Already used 2 lynches today. Continue?");
        if (!ok) return;
      } else if (state.day.lynchCount >= 1 && !state.day.troublemakerActiveToday){
        if (!state.day.lynchWarned){
          const ok = await confirmModal("There has already been a lynch today. Continue?");
          if (!ok) return;
          state.day.lynchWarned = true;
        } else {
          const ok = await confirmModal("Second lynch without Troublemaker. Continue?");
          if (!ok) return;
        }
      }
      const ok = killPlayer(state.vote.selectedId, "vote");
      if (!ok) return;
      state.day.lynchCount++;

      const killed = state.players.find(p => p.id === state.vote.selectedId);
      if (killed && killed.role === ROLE.HUNTER){
        state.day.pendingHunterMarkId = state.night.hunterMarkId;
      }

      state.day.announcements = [];
      announce(`${labelPlayer(state.vote.selectedId)} was lynched.`);
      if (state.day.troublemakerActiveToday && state.day.lynchCount === 1){
        announce("Troublemaker activated: 2 lynches allowed today.");
      }

      // AUTO win (includes tanner rule)
      checkWinAuto({ kind: "voteKill", playerId: state.vote.selectedId });

      if (state.winner) return;
      showScreen(4);
    };

    $("spareByVoteBtn").onclick = () => {
      state.day.announcements = [];
      announce(`${state.vote.selectedId ? labelPlayer(state.vote.selectedId) : "Selected player"} was spared.`);
      if (state.day.troublemakerActiveToday && state.day.lynchCount === 1){
        announce("Troublemaker activated: 2 lynches allowed today.");
      }
      state.day.lynchCount++;
      // no win check on spare (optional), but still can happen if already reached condition
      checkWinAuto();
      if (state.winner) return;
      showScreen(4);
    };

    $("backToDayBtn").onclick = () => showScreen(4);

    // Manual screen back
    $("backFromManualBtn").onclick = () => {
      // go back to night (same night), step reset to wolf to avoid confusion
      state.night.stepIndex = 0;
      renderNight();
      showScreen(3);
    };

    // Winner screen
    $("restartBtn").onclick = () => {
      state.gameStarted = false;
      state.players.forEach(p => p.alive = true);
      state.day.lastNightLog = [];
      state.day.announcements = [];
      state.day.dayDeaths = [];
      state.day.wolfCubDiedLastDay = false;
      state.day.pendingHunterMarkId = null;
      state.day.lynchCount = 0;
      state.day.lynchWarned = false;
      state.day.lastBodyguardId = null;
      state.day.skipWolfBiteNextNight = false;
    state.day.troublemakerUsed = false;
    state.day.troublemakerActiveToday = false;
    state.day.troublemakerPendingNextDay = false;
    state.day.troublemakerLastUseNight = null;
      state.day.pendingToughGuyId = null;
      state.day.pendingToughGuyNight = null;
      state.day.piUses = 0;
      state.day.piLastUseNight = null;

      stopDayTimer(); state.timers.day = 0; $("dayTimerText").textContent = "00:00";
      stopVoteTimer(); state.vote.timer = 0; $("lynchTimerText").textContent = "00:00";

      state.night.number = 1;
      resetNightState({keepPotions:false});
      state.winner = null;

      renderPlayersTextarea();
      renderRoleTables();
      updateQuickStatus();
      showScreen(1);
    };

    $("backToDayFromWinBtn").onclick = () => {
      state.winner = null;
      showScreen(4);
    };

  }

  window.addEventListener("beforeunload", saveState);
  init();
})();
</script>
</body>
</html>


